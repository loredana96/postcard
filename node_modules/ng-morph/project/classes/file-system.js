"use strict";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NgCliFileSystem = exports.FileSystem = void 0;
const tslib_1 = require("tslib");
const path_1 = require("path");
const multimatch = require("multimatch");
/**
 * Abstraction of the file system that migrations can use to record and apply
 * changes. This is necessary to support virtual file systems as used in the CLI devkit.
 */
class FileSystem {
}
exports.FileSystem = FileSystem;
class NgCliFileSystem {
    constructor(fs) {
        this.fs = fs;
    }
    copy(srcPath, destPath) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.copySync(srcPath, destPath);
        });
    }
    copySync(srcPath, destPath) {
        if (this.fileExistsSync(srcPath)) {
            this.writeFileSync(destPath, this.readFileSync(srcPath));
        }
        else if (this.directoryExistsSync(srcPath)) {
            const paths = this.readDirSync(srcPath);
            paths.forEach((path) => this.copySync(path, path_1.join(destPath, path_1.basename(path))));
        }
    }
    delete(path) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.deleteSync(path);
        });
    }
    deleteSync(path) {
        this.fs.delete(path);
    }
    directoryExists(dirPath) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.directoryExistsSync(dirPath);
        });
    }
    directoryExistsSync(dirPath) {
        return (this.fs.exists(dirPath) && !this.fileExistsSync(dirPath));
    }
    fileExists(filePath) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.fileExistsSync(filePath);
        });
    }
    fileExistsSync(filePath) {
        try {
            return this.fs.read(filePath) !== null;
        }
        catch (e) {
            return false;
        }
    }
    getCurrentDirectory() {
        return '/';
    }
    glob(patterns) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.globSync(patterns);
        });
    }
    globSync(patterns) {
        return multimatch(this.getAllFilePaths(), patterns);
    }
    isCaseSensitive() {
        return true;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    mkdir(dirPath) {
        return Promise.resolve(undefined);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    mkdirSync(dirPath) {
        // empty
    }
    move(srcPath, destPath) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.moveSync(srcPath, destPath);
        });
    }
    moveSync(srcPath, destPath) {
        this.copySync(srcPath, destPath);
        this.deleteSync(srcPath);
    }
    readDirSync(dirPath) {
        const { directories, files } = this.fs.readDirectory(dirPath);
        return [...directories, ...files];
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    readFile(filePath, encoding) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.readFileSync(filePath);
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    readFileSync(filePath, encoding) {
        return this.fs.read(filePath);
    }
    realpathSync(path) {
        return path;
    }
    writeFile(filePath, fileText) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.writeFileSync(filePath, fileText);
        });
    }
    writeFileSync(filePath, fileText) {
        if (this.fileExistsSync(filePath)) {
            this.fs.overwrite(filePath, fileText);
        }
        else {
            this.fs.create(filePath, fileText);
        }
    }
    getAllFilePaths(path = '/', foundedFiles = []) {
        const { directories, files } = this.fs.readDirectory(path);
        foundedFiles.push(...files.map((file) => path_1.join(path, file)));
        directories
            .filter((dir) => !dir.startsWith('.') && dir !== 'node_modules')
            .forEach((dir) => this.getAllFilePaths(path_1.join(path, dir), foundedFiles));
        return foundedFiles;
    }
}
exports.NgCliFileSystem = NgCliFileSystem;
//# sourceMappingURL=file-system.js.map