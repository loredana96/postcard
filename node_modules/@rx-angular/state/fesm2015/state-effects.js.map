{"version":3,"file":"state-effects.js","sources":["../../../../libs/state/effects/src/lib/utils.ts","../../../../libs/state/effects/src/lib/effects.service.ts","../../../../libs/state/effects/src/state-effects.ts"],"sourcesContent":["import { MonoTypeOperatorFunction, Observable } from 'rxjs';\nimport { filter, pluck, shareReplay, take, takeUntil } from 'rxjs/operators';\nimport { HookProps, OnDestroy$, SingleShotProps } from './model';\n\nexport function isSingleShotHookNameGuard<T>(\n  name: unknown\n): name is keyof SingleShotProps {\n  return !!name && typeof name === 'string' && name !== '';\n}\n\n/**\n * @internal\n * Operator to filter values for single shot observables\n */\nconst singleShotOperators = (o$: Observable<true>): Observable<true> =>\n  o$.pipe(\n    filter((v) => v === true),\n    take(1),\n    shareReplay()\n  );\n\n/**\n * This is an operator that is used to listen to Angular lifecycle hooks.\n * It plucks a defined lefe cycle name `HookProps` and forwards values for the particular value and in the behavior of the hook e.g. single shot\n *\n * @param name\n */\nexport function toHook<H extends keyof HookProps>(name: H) {\n  const operators = isSingleShotHookNameGuard(name)\n    ? singleShotOperators\n    : (o: Observable<HookProps[H]>): Observable<true> => o;\n  return (o$: Observable<HookProps>): Observable<HookProps[H]> =>\n    o$.pipe(pluck(name), operators);\n}\n\n/**\n * This operator can be used to take instances that implements `OnDestroy$` and unsubscribes from the given Observable when the instances\n * `onDestroy$` Observable emits.\n *\n * @param instanceWithLifecycle\n */\nexport function untilDestroyed<V>(\n  instanceWithLifecycle: OnDestroy$\n): MonoTypeOperatorFunction<V> {\n  return (source) =>\n    source.pipe(takeUntil<V>(instanceWithLifecycle.onDestroy$));\n}\n","import { ErrorHandler, Injectable, OnDestroy, Optional } from '@angular/core';\nimport {\n  EMPTY,\n  from,\n  Observable,\n  ObservableInput,\n  PartialObserver,\n  pipe,\n  Subject,\n  Subscription\n} from 'rxjs';\nimport {\n  catchError,\n  filter,\n  mapTo,\n  mergeAll,\n  share,\n  takeUntil,\n  tap\n} from 'rxjs/operators';\nimport { DestroyProp, OnDestroy$ } from './model';\nimport { toHook, untilDestroyed } from './utils';\n\n/**\n * Reduces subscription boilerplate for performing observable-based side-effects in components.\n *\n * Before:\n * ```ts\n * @Component({\n *   // ...\n * })\n * export class FooComponent implements OnDestroy {\n *   private readonly destroy$ = new Subject<void>();\n *\n *   constructor() {\n *     obs$.pipe(takeUntil(this.destroy$)).subscribe(doSideEffect);\n *   }\n *\n *   ngOnDestroy(): void {\n *     this.destroy$.next();\n *     this.destroy$.complete();\n *   }\n * }\n * ```\n *\n * After:\n * ```ts\n * @Component({\n *   // ...\n *   providers: [RxEffects],\n * })\n * export class FooComponent {\n *   constructor(effects: RxEffects) {\n *     effects.register(obs$, doSideEffect);\n *     // OR\n *     effects.register(obs$.pipe(tap(doSideEffect)));\n *     // OR\n *     effects.register(obs$.subscribe(doSideEffect));\n *   }\n * }\n * ```\n *\n * NOTE: Avoid calling register/unregister/subscribe inside the side-effect function.\n */\n@Injectable()\nexport class RxEffects implements OnDestroy, OnDestroy$ {\n  constructor(\n    @Optional()\n    private readonly errorHandler: ErrorHandler\n  ) {}\n\n  private static nextId = 0;\n  readonly _hooks$ = new Subject<DestroyProp>();\n  private readonly observables$ = new Subject<Observable<unknown>>();\n  // we have to use publish here to make it hot (composition happens without subscriber)\n  private readonly effects$ = this.observables$.pipe(mergeAll(), share());\n  private readonly subscription = this.effects$.subscribe();\n  onDestroy$: Observable<boolean> = this._hooks$.pipe(toHook('destroy'));\n  private readonly destroyers: Record<number, Subject<void>> = {};\n\n  /**\n   * Performs a side-effect whenever a source observable emits, and handles its subscription.\n   *\n   * @example\n   * effects.register(\n   *   colorMode$,\n   *   mode => localStorage.setItem('colorMode', mode)\n   * );\n   *\n   * @param sourceObs Source observable input\n   * @param sideEffectFn Function with side-effect\n   * @returns Effect ID (can be used to unregister imperatively)\n   */\n  register<T>(\n    sourceObs: ObservableInput<T>,\n    sideEffectFn: (value: T) => void\n  ): number;\n\n  /**\n   * Subscribe to source observable using an observer object.\n   *\n   * @example\n   * effects.register(\n   *   colorMode$,\n   *   {\n   *     next: mode => localStorage.setItem('colorMode', mode),\n   *     error: err => {\n   *       console.error('Color mode error: ', err);\n   *       localStorage.removeItem('colorMode');\n   *     }\n   *   }\n   * );\n   *\n   * @param sourceObs Source observable input\n   * @param observer Observer object\n   */\n  register<T>(\n    sourceObs: ObservableInput<T>,\n    // tslint:disable-next-line: unified-signatures\n    observer: PartialObserver<T>\n  ): number;\n\n  /**\n   * Handles subscription for an observable with a side-effect.\n   *\n   * @example\n   * effects.register(\n   *   colorMode$.pipe(\n   *     tap(mode => localStorage.setItem('colorMode', mode))\n   *   )\n   * );\n   *\n   * @param sideEffectObs Observable input with side-effect\n   * @returns Effect ID (can be used to unregister imperatively)\n   */\n  register(sideEffectObs: ObservableInput<unknown>): number;\n\n  /**\n   * Handles subscription to an observable with a side-effect.\n   *\n   * @example\n   * effects.register(\n   *   colorMode$.subscribe(mode => localStorage.setItem('colorMode', mode))\n   * );\n   *\n   * @param subscription Subscription to observable with side-effect\n   */\n  // tslint:disable-next-line: unified-signatures\n  register(subscription: Subscription): void;\n\n  register<T>(\n    obsOrSub: ObservableInput<T> | Subscription,\n    fnOrObj?: ((value: T) => void) | PartialObserver<T>\n  ): number | void {\n    if (obsOrSub instanceof Subscription) {\n      this.subscription.add(obsOrSub);\n      return;\n    }\n    const effectId = RxEffects.nextId++;\n    const destroy$ = (this.destroyers[effectId] = new Subject<void>());\n    const applyBehavior = pipe(mapTo(effectId), takeUntil(destroy$));\n    if (fnOrObj != null) {\n      this.observables$.next(\n        from(obsOrSub).pipe(\n          // ternary expression is to help Typescript infer overloads\n          typeof fnOrObj === 'function' ? tap(fnOrObj) : tap(fnOrObj),\n          catchError((err) => {\n            this.errorHandler?.handleError(err);\n            return EMPTY;\n          }),\n          applyBehavior\n        )\n      );\n    } else {\n      this.observables$.next(from(obsOrSub).pipe(applyBehavior));\n    }\n    return effectId;\n  }\n\n  /**\n   * Imperatively cancel a side-effect while the component is still running.\n   *\n   * Note that all effects are automatically cancelled when a component is destroyed,\n   * so you most often won't need to call this method.\n   * @param effectId Effect ID (returned by register method)\n   */\n  unregister(effectId: number): void {\n    this.destroyers[effectId]?.next();\n  }\n\n  /**\n   * Fires a sideEffect when the instances `OnDestroy` hook is fired.\n   *\n   * @example\n   * effects.registerOnDestroy(mode => localStorage.setItem('colorMode', mode));\n   *\n   * @param sideEffect\n   */\n  registerOnDestroy(sideEffect: (value: boolean) => void): number | void {\n    return this.register(this.onDestroy$, sideEffect);\n  }\n\n  /**\n   * Operator that unsubscribes based on emission of an registered effect.\n   *\n   * @NOTICE\n   * This operator has to be placed always at the end of the operator chain (before the subscription).\n   * Otherwise we may leak as a subsequent operator could instantiate new ongoing Observables which will not get unsubscribed.\n   *\n   * @example\n   * const effectId1 = effects.register(\n   *   colorMode$.subscribe(mode => localStorage.setItem('colorMode', mode))\n   * );\n   *\n   * someValue$.pipe(\n   *    effect.untilEffect(effectId1)\n   * )\n   *\n   */\n  untilEffect(effectId: number) {\n    return <V>(source: Observable<V>) =>\n      source.pipe(\n        untilDestroyed(this),\n        takeUntil(this.effects$.pipe(filter((eId) => eId === effectId)))\n      );\n  }\n\n  /**\n   * @internal\n   */\n  ngOnDestroy(): void {\n    this._hooks$.next({ destroy: true });\n    this.subscription.unsubscribe();\n  }\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":";;;;;SAIgB,yBAAyB,CACvC,IAAa;IAEb,OAAO,CAAC,CAAC,IAAI,IAAI,OAAO,IAAI,KAAK,QAAQ,IAAI,IAAI,KAAK,EAAE,CAAC;AAC3D,CAAC;AAED;;;;AAIA,MAAM,mBAAmB,GAAG,CAAC,EAAoB,KAC/C,EAAE,CAAC,IAAI,CACL,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,IAAI,CAAC,EACzB,IAAI,CAAC,CAAC,CAAC,EACP,WAAW,EAAE,CACd,CAAC;AAEJ;;;;;;SAMgB,MAAM,CAA4B,IAAO;IACvD,MAAM,SAAS,GAAG,yBAAyB,CAAC,IAAI,CAAC;UAC7C,mBAAmB;UACnB,CAAC,CAA2B,KAAuB,CAAC,CAAC;IACzD,OAAO,CAAC,EAAyB,KAC/B,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,SAAS,CAAC,CAAC;AACpC,CAAC;AAED;;;;;;SAMgB,cAAc,CAC5B,qBAAiC;IAEjC,OAAO,CAAC,MAAM,KACZ,MAAM,CAAC,IAAI,CAAC,SAAS,CAAI,qBAAqB,CAAC,UAAU,CAAC,CAAC,CAAC;AAChE;;ACvBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA0Ca,SAAS;IACpB,YAEmB,YAA0B;QAA1B,iBAAY,GAAZ,YAAY,CAAc;QAIpC,YAAO,GAAG,IAAI,OAAO,EAAe,CAAC;QAC7B,iBAAY,GAAG,IAAI,OAAO,EAAuB,CAAC;;QAElD,aAAQ,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,KAAK,EAAE,CAAC,CAAC;QACvD,iBAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,CAAC;QAC1D,eAAU,GAAwB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC;QACtD,eAAU,GAAkC,EAAE,CAAC;KAT5D;IAiFJ,QAAQ,CACN,QAA2C,EAC3C,OAAmD;QAEnD,IAAI,QAAQ,YAAY,YAAY,EAAE;YACpC,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;YAChC,OAAO;SACR;QACD,MAAM,QAAQ,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC;QACpC,MAAM,QAAQ,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,GAAG,IAAI,OAAO,EAAQ,CAAC,CAAC;QACnE,MAAM,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC;QACjE,IAAI,OAAO,IAAI,IAAI,EAAE;YACnB,IAAI,CAAC,YAAY,CAAC,IAAI,CACpB,IAAI,CAAC,QAAQ,CAAC,CAAC,IAAI;;YAEjB,OAAO,OAAO,KAAK,UAAU,GAAG,GAAG,CAAC,OAAO,CAAC,GAAG,GAAG,CAAC,OAAO,CAAC,EAC3D,UAAU,CAAC,CAAC,GAAG;;gBACb,MAAA,IAAI,CAAC,YAAY,0CAAE,WAAW,CAAC,GAAG,CAAC,CAAC;gBACpC,OAAO,KAAK,CAAC;aACd,CAAC,EACF,aAAa,CACd,CACF,CAAC;SACH;aAAM;YACL,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;SAC5D;QACD,OAAO,QAAQ,CAAC;KACjB;;;;;;;;IASD,UAAU,CAAC,QAAgB;;QACzB,MAAA,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,0CAAE,IAAI,EAAE,CAAC;KACnC;;;;;;;;;IAUD,iBAAiB,CAAC,UAAoC;QACpD,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;KACnD;;;;;;;;;;;;;;;;;;IAmBD,WAAW,CAAC,QAAgB;QAC1B,OAAO,CAAI,MAAqB,KAC9B,MAAM,CAAC,IAAI,CACT,cAAc,CAAC,IAAI,CAAC,EACpB,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,KAAK,GAAG,KAAK,QAAQ,CAAC,CAAC,CAAC,CACjE,CAAC;KACL;;;;IAKD,WAAW;QACT,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC;QACrC,IAAI,CAAC,YAAY,CAAC,WAAW,EAAE,CAAC;KACjC;;AAlKc,gBAAM,GAAG,CAAC,CAAC;0HANf,SAAS;8HAAT,SAAS;4FAAT,SAAS;kBADrB,UAAU;;0BAGN,QAAQ;;;ACnEb;;;;;;"}