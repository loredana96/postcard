{"version":3,"file":"state-selections.js","sources":["../../../../libs/state/selections/src/lib/accumulation-observable.ts","../../../../libs/state/selections/src/lib/utils/guards.ts","../../../../libs/state/selections/src/lib/utils/pipe-from-array.ts","../../../../libs/state/selections/src/lib/operators/stateful.ts","../../../../libs/state/selections/src/lib/utils/safe-pluck.ts","../../../../libs/state/selections/src/lib/operators/distinctUntilSomeChanged.ts","../../../../libs/state/selections/src/lib/operators/selectSlice.ts","../../../../libs/state/selections/src/lib/operators/select.ts","../../../../libs/state/selections/src/lib/side-effect-observable.ts","../../../../libs/state/selections/src/state-selections.ts"],"sourcesContent":["import {\n  BehaviorSubject,\n  ConnectableObservable,\n  EMPTY,\n  merge,\n  Observable,\n  queueScheduler,\n  Subject,\n  Subscription,\n} from 'rxjs';\nimport {\n  catchError,\n  distinctUntilChanged,\n  mergeAll,\n  observeOn,\n  publish,\n  publishReplay,\n  scan,\n  tap,\n  withLatestFrom,\n} from 'rxjs/operators';\nimport { AccumulationFn, Accumulator } from './model';\n\nconst defaultAccumulator: AccumulationFn = <T>(st: T, sl: Partial<T>): T => {\n  return { ...st, ...sl };\n};\n\nexport function createAccumulationObservable<T extends object>(\n  stateObservables = new Subject<Observable<Partial<T>>>(),\n  stateSlices = new Subject<Partial<T>>(),\n  accumulatorObservable = new BehaviorSubject(defaultAccumulator)\n): Accumulator<T> {\n  const signal$ = merge(\n    stateObservables.pipe(\n      distinctUntilChanged(),\n      mergeAll(),\n      observeOn(queueScheduler)\n    ),\n    stateSlices.pipe(observeOn(queueScheduler))\n  ).pipe(\n    withLatestFrom(accumulatorObservable.pipe(observeOn(queueScheduler))),\n    scan(\n      (state, [slice, stateAccumulator]) => stateAccumulator(state, slice),\n      {} as T\n    ),\n    tap(\n      (newState) => (compositionObservable.state = newState),\n      (error) => console.error(error)\n    ),\n    // @Notice We catch the error here as it get lost in between `publish` and `publishReplay`. We return empty to\n    catchError((e) => EMPTY),\n    publish()\n  );\n  const state$: Observable<T> = signal$.pipe(publishReplay(1));\n  const compositionObservable: Accumulator<T> = {\n    state: {} as T,\n    signal$,\n    state$,\n    nextSlice,\n    nextSliceObservable,\n    nextAccumulator,\n    subscribe,\n  };\n\n  // ======\n\n  return compositionObservable;\n\n  // ======\n\n  function nextAccumulator(accumulatorFn: AccumulationFn): void {\n    accumulatorObservable.next(accumulatorFn);\n  }\n\n  function nextSlice(stateSlice: Partial<T>): void {\n    stateSlices.next(stateSlice);\n  }\n\n  function nextSliceObservable(stateObservable: Observable<Partial<T>>): void {\n    stateObservables.next(stateObservable);\n  }\n\n  function subscribe(): Subscription {\n    const sub = (\n      compositionObservable.signal$ as ConnectableObservable<T>\n    ).connect();\n    sub.add(\n      (compositionObservable.state$ as ConnectableObservable<T>).connect()\n    );\n    sub.add(() => {\n      accumulatorObservable.complete();\n      stateObservables.complete();\n      stateSlices.complete();\n    });\n    return sub;\n  }\n}\n","import { OperatorFunction } from 'rxjs';\n\nexport function isPromiseGuard<T>(value: unknown): value is Promise<T> {\n  return (\n    value !== null &&\n    value !== undefined &&\n    typeof (<any>value).subscribe !== 'function' &&\n    typeof (value as any).then === 'function'\n  );\n}\n\nexport function isOperateFnArrayGuard<T, R = T>(\n  op: any[]\n): op is OperatorFunction<T, R>[] {\n  if (!Array.isArray(op)) {\n    return false;\n  }\n  return op.length > 0 && op.every((i: any) => typeof i === 'function');\n}\n\nexport function isStringArrayGuard(op: any[]): op is string[] {\n  if (!Array.isArray(op)) {\n    return false;\n  }\n  return op.length > 0 && op.every((i: any) => typeof i === 'string');\n}\n\nexport function isIterableGuard<T>(obj: unknown): obj is Array<T> {\n  if (obj === null || obj === undefined) {\n    return false;\n  }\n  return typeof (obj as any)[Symbol.iterator] === 'function';\n}\n\nexport function isKeyOf<O>(k: unknown): k is keyof O {\n  const typeofK = typeof k;\n  return (\n    k !== null &&\n    k !== undefined &&\n    ['string', 'symbol', 'number'].includes(typeofK)\n  );\n}\n\nexport function isObjectGuard(obj: unknown): obj is object {\n  return (\n    obj !== null &&\n    obj !== undefined &&\n    typeof obj === 'object' &&\n    !Array.isArray(obj)\n  );\n}\n\nexport function isDefined(val: unknown): val is NonNullable<any> {\n  return val !== null && val !== undefined;\n}\n\nexport function isStringAndFunctionTupleGuard<R>(\n  op: unknown[]\n): op is [string, (val: any) => R] {\n  return typeof op[0] === 'string' && typeof op[1] === 'function';\n}\n\nexport function isStringArrayFunctionAndOptionalObjectTupleGuard<R>(\n  op: unknown[]\n): op is [strs: string[], fn: (val: any) => R, obj?: object] {\n  return (\n    isStringArrayGuard(op[0] as any) &&\n    typeof op[1] === 'function' &&\n    (op[2] === undefined || typeof op[2] === 'object')\n  );\n}\n","import { noop, UnaryFunction } from 'rxjs';\n\nexport function pipeFromArray<T, R>(\n  fns: Array<UnaryFunction<T, R>>\n): UnaryFunction<T, R> {\n  if (!fns) {\n    return noop as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce(\n      (prev: any, fn: UnaryFunction<T, R>) => fn(prev),\n      input as any\n    );\n  };\n}\n","import { Observable, OperatorFunction } from 'rxjs';\nimport { distinctUntilChanged, filter, shareReplay } from 'rxjs/operators';\nimport { NonUndefined } from '../interfaces';\nimport { isOperateFnArrayGuard } from '../utils/guards';\nimport { pipeFromArray } from '../utils/pipe-from-array';\n\n/**\n * @description\n *\n * As the name `stateful` implies this operator is useful when you process an Observable which maintains state.\n *\n * Maintaining state as an `Observable` source comes with a handful of repetitive as well as use case specific tasks.\n *\n * It acts like the Observables `pipe` method.\n * It accepts RxJS operators and composes them like `Observable#pipe` and the standalone `pipe` method.\n *\n * Furthermore, it takes care of the above mentioned repetitive tasks as listed below.\n *\n * You will always (aka repetitive) want to ensure that:\n * - only distinct state changes are emitted\n * - only defined values are emitted (filter out undefined, which ensures lazy state)\n * - share and replay custom operations for multiple subscribers (saves performance)\n *\n * You will sometimes (aka situational) need:\n * - a subset of the state (derivations)\n * - compose the state with other Observables or change the Observables behaviour\n *\n *\n * @example\n * import { Observable } from 'rxjs';\n * import { map } from 'rxjs/operators';\n * import { stateful } from 'rx-angular/state';\n *\n * const state$: Observable<{ name: string; items: string[] }>;\n * const derivation$ = state$.pipe(\n *   stateful(\n *     map(state => state.list.length),\n *     filter(length => length > 3)\n *   )\n * );\n *\n * @param {OperatorFunction<T, A>} op - one or multiple passed operator comma separated\n * @return OperatorFunction<T, NonUndefined<A>>\n *\n * @docsPage stateful\n * @docsCategory operators\n */\nexport function stateful<T>(): OperatorFunction<T, NonUndefined<T>>;\n/**\n * @internal\n */\nexport function stateful<T, A>(\n  op: OperatorFunction<T, A>\n): OperatorFunction<T, NonUndefined<A>>;\n/**\n * @internal\n */\nexport function stateful<T, A, B>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>\n): OperatorFunction<T, NonUndefined<B>>;\n/**\n * @internal\n */\nexport function stateful<T, A, B, C>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>\n): OperatorFunction<T, NonUndefined<C>>;\n/**\n * @internal\n */\nexport function stateful<T, A, B, C, D>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>\n): OperatorFunction<T, NonUndefined<D>>;\n/**\n * @internal\n */\nexport function stateful<T, A, B, C, D, E>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>,\n  op5: OperatorFunction<D, E>\n): OperatorFunction<T, NonUndefined<E>>;\n/**\n * @description\n *\n * As it acts like the Observables `pipe` method, it accepts one or many RxJS operators as params.\n *\n * @example\n * import { Observable } from 'rxjs';\n * import { map } from 'rxjs/operators';\n * import { stateful } from 'rx-angular/state';\n *\n * const state$: Observable<{ name: string; items: string[] }>;\n * const derivation$ = state$.pipe(\n *   stateful(\n *     map(state => state.list.length),\n *     filter(length => length > 3)\n *   )\n * );\n *\n * @param {OperatorFunction<T, A>} op - one or multiple passed operator comma separated\n *\n * @docsPage stateful\n * @docsCategory operators\n */\nexport function stateful<T, R>(\n  ...optionalDerive: OperatorFunction<T, R>[]\n): OperatorFunction<T, NonUndefined<T> | NonUndefined<R>> {\n  return (s: Observable<T>): Observable<NonUndefined<T> | NonUndefined<R>> => {\n    return s.pipe(\n      // distinct same base-state objects (e.g. a default emission of default switch cases, incorrect mutable handling\n      // of data) @TODO evaluate benefits vs. overhead\n      distinctUntilChanged(),\n      // CUSTOM LOGIC HERE\n      (o: Observable<T>): Observable<T | R> => {\n        if (isOperateFnArrayGuard(optionalDerive)) {\n          return o.pipe(pipeFromArray(optionalDerive));\n        }\n        return o;\n      },\n      // initial emissions, undefined is no base-state, pollution with skip(1)\n      filter((v): v is NonUndefined<typeof v> => v !== undefined),\n      // distinct same derivation value\n      distinctUntilChanged(),\n      // reuse custom operations result for multiple subscribers and reemit the last calculated value.\n      shareReplay({ bufferSize: 1, refCount: true })\n    );\n  };\n}\n","import { isDefined, isKeyOf, isObjectGuard } from './guards';\n\nexport function safePluck<T extends object, K1 extends keyof T>(\n  stateObject: T,\n  keys: K1 | [K1]\n): T[K1];\n\nexport function safePluck<T extends object,\n  K1 extends keyof T,\n  K2 extends keyof T[K1]>(stateObject: T, keys: [K1, K2]): T[K1][K2];\n\nexport function safePluck<T extends object,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2]>(stateObject: T, keys: [K1, K2, K3]): T[K1][K2][K3];\n\nexport function safePluck<T extends object,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3]>(stateObject: T, keys: [K1, K2, K3, K4]): T[K1][K2][K3][K4];\n\nexport function safePluck<T extends object,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n  K5 extends keyof T[K1][K2][K3][K4]>(stateObject: T, keys: [K1, K2, K3, K4, K5]): T[K1][K2][K3][K4][K5];\n\nexport function safePluck<T extends object,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n  K5 extends keyof T[K1][K2][K3][K4],\n  K6 extends keyof T[K1][K2][K3][K4][K5]>(\n  stateObject: T,\n  keys:\n    | [K1]\n    | [K1, K2]\n    | [K1, K2, K3]\n    | [K1, K2, K3, K4]\n    | [K1, K2, K3, K4, K5]\n    | [K1, K2, K3, K4, K5, K6]\n): T[K1][K2][K3][K4][K5][K6];\n\nexport function safePluck<T extends object,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n  K5 extends keyof T[K1][K2][K3][K4],\n  K6 extends keyof T[K1][K2][K3][K4][K5]>(\n  stateObject: T,\n  keys:\n    | [K1]\n    | [K1, K2]\n    | [K1, K2, K3]\n    | [K1, K2, K3, K4]\n    | [K1, K2, K3, K4, K5]\n    | [K1, K2, K3, K4, K5, K6]\n):\n  | T[K1]\n  | T[K1][K2]\n  | T[K1][K2][K3]\n  | T[K1][K2][K3][K4]\n  | T[K1][K2][K3][K4][K5]\n  | T[K1][K2][K3][K4][K5][K6]\n  | null\n  | undefined {\n  // needed to match null and undefined conventions of RxAngular core components\n  // safePluck(null) -> return null\n  // safePluck(undefined) -> return undefined\n  // safePluck(obj, ['wrongKey']) -> return undefined\n  // safePluck(obj, ['correctKey']) -> return value of key\n  // safePluck(obj, '') -> return undefined\n  // safePluck(obj, null) -> return undefined\n  if (!isDefined(stateObject)) {\n    return stateObject;\n  }\n  if (!isDefined(keys)) {\n    return undefined;\n  }\n  // sanitize keys -> keep only valid keys (string, number, symbol)\n  const keysArr = (Array.isArray(keys) ? keys : [keys]).filter(k =>\n    isKeyOf<T>(k)\n  );\n  if (\n    keysArr.length === 0 ||\n    !isObjectGuard(stateObject) ||\n    Object.keys(stateObject).length === 0\n  ) {\n    return undefined;\n  }\n  let prop = stateObject[keysArr.shift() as K1];\n\n  keysArr.forEach(key => {\n    if (isObjectGuard(prop) && isKeyOf(key)) {\n      prop = prop[key];\n    }\n  });\n  return prop;\n}\n","import { MonoTypeOperatorFunction } from 'rxjs';\nimport { distinctUntilChanged } from 'rxjs/operators';\nimport { CompareFn, KeyCompareMap } from '../interfaces/index';\nimport { safePluck } from '../utils/safe-pluck';\n\n/**\n * @internal\n */\nfunction defaultCompare<T>(oldVal: T, newVal: T): boolean {\n  return oldVal === newVal;\n}\n\n/**\n * @description\n *\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from\n * the previous item. Comparison will be done for each set key in the `keys` array.\n *\n * You can fine grain your distinct checks by providing a `KeyCompareMap` with those keys you want to compute\n * explicitly different\n *\n * The name `distinctUntilSomeChanged` was picked since it internally iterates over the `keys` and utilizes the\n * [some](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/some) method in order to\n * compute if values are distinct or not.\n *\n * @example\n *\n * import { of } from 'rxjs';\n * import { distinctUntilSomeChanged } from 'rx-angular/state';\n *\n * interface Person {\n *    age: number;\n *    name: string;\n * }\n *\n * of(\n *   { age: 4, name: 'Hans'},\n *   { age: 7, name: 'Sophie'},\n *   { age: 5, name: 'Han Solo'},\n *   { age: 5, name: 'HanSophie'},\n * ).pipe(\n *   distinctUntilSomeChanged(['age', 'name']),\n * )\n * .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Hans'}\n * // { age: 7, name: 'Sophie'}\n * // { age: 5, name: 'Han Solo'}\n * // { age: 5, name: 'HanSophie'}\n *\n * @example\n * // An example with `KeyCompareMap`\n * import { of } from 'rxjs';\n * import { distinctUntilSomeChanged } from 'rxjs/operators';\n *\n * interface Person {\n *     age: number;\n *     name: string;\n *  }\n * const customComparison: KeyCompareMap<Person> = {\n *   name: (oldName, newName) => oldName.substring(0, 2) === newName.substring(0, 2)\n * };\n *\n * of(\n *     { age: 4, name: 'Hans'},\n *     { age: 7, name: 'Sophie'},\n *     { age: 5, name: 'Han Solo'},\n *     { age: 5, name: 'HanSophie'},\n *   ).pipe(\n *     distinctUntilSomeChanged(['age', 'name'], customComparison),\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Hans' }\n * // { age: 7, name: 'Sophie' }\n * // { age: 5, name: 'Han Solo' }\n *\n * @param {K[]} keys String key for object property lookup on each item.\n * @param {KeyCompareMap<T>} [compare] Optional KeyCompareMap to explicitly define comparisons for some of the keys\n * @docsPage distinctUntilSomeChanged\n * @docsCategory operators\n */\nexport function distinctUntilSomeChanged<T extends object, K extends keyof T>(\n  keys: K[],\n  keyCompareMap?: KeyCompareMap<T>\n): MonoTypeOperatorFunction<T> {\n  // default compare function applying === to every key\n  let distinctCompare: CompareFn<T> = (oldState, newState) =>\n    keys.some(\n      (key) =>\n        !defaultCompare(safePluck(oldState, [key]), safePluck(newState, [key]))\n    );\n\n  // generate compare function respecting every case of provided keyCompareMap\n  if (keyCompareMap !== undefined) {\n    const compare = (key: K) => {\n      return keyCompareMap.hasOwnProperty(key) &&\n      keyCompareMap[key] !== undefined\n        ? (keyCompareMap[key] as CompareFn<T[K]>)\n        : defaultCompare;\n    };\n    distinctCompare = (oldState, newState) => {\n      return keys.some(\n        (key) =>\n          !compare(key)(safePluck(oldState, [key]), safePluck(newState, [key]))\n      );\n    };\n  }\n  return distinctUntilChanged((oldV, newV) => !distinctCompare(oldV, newV));\n}\n","import { Observable, OperatorFunction } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\nimport { KeyCompareMap, PickSlice } from '../interfaces/index';\nimport { distinctUntilSomeChanged } from './distinctUntilSomeChanged';\n\n/**\n * @description\n *\n * Returns an Observable that emits only the provided `keys` emitted by the source Observable. Each key will get\n * filtered to only emit _defined_ values as well as checked for distinct emissions.\n * Comparison will be done for each set key in the `keys` array.\n *\n * `selectSlice` will only emit _valid_ selections. A selection is _valid_ if every\n * selected key exists and is defined in the source Observable. This ensures that the `selectSlice`\n * operator will always return a complete slice with all values defined.\n *\n * You can fine grain your distinct checks by providing a `KeyCompareMap` with those keys you want to compute\n * explicitly different\n *\n * @example\n *\n * // An example with a custom comparison applied to each key\n * import { of } from 'rxjs';\n * import { selectSlice } from 'rx-angular/state';\n *\n *\n * const state$: Observable<MyState> = of(\n *  { title: 'myTitle', panelOpen: true},\n *  { title: 'myTitle2', panelOpen: true},\n *  { title: 'newTitle', panelOpen: true},\n *  { title: 'newTitle', panelOpen: false}\n * )\n * .pipe(\n *     selectSlice(['title', 'panelOpen']),\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // displays:\n * //  { title: 'myTitle', panelOpen: true },\n * //  { title: 'myTitle2', panelOpen: true },\n * //  { title: 'newTitle', panelOpen: true },\n * //  { title: 'newTitle', panelOpen: false }\n *\n * @example\n *\n * import { of, Observable } from 'rxjs';\n * import { tap } from 'rxjs/operators';\n * import { selectSlice } from 'rx-angular/state';\n *\n * interface MyState {\n *    title: string;\n *    items: string[];\n *    panelOpen: boolean;\n * }\n * // Select items and title.\n * // apply custom compare logic for the items array\n * const customComparison: KeyCompareMap<MyState> = {\n *   items: (oldItems, newItems) => compareItems(oldItems, newItems)\n * };\n * const state$: Observable<MyState> = of(\n * { title: 'myTitle', items: ['foo', 'bar'], panelOpen: true },\n * { title: 'myTitle', items: ['foo', 'bar'], panelOpen: false },\n * { title: 'nextTitle', items: ['foo', 'baR'], panelOpen: true },\n * { title: 'nextTitle', items: ['fooRz', 'boo'], panelOpen: false },\n * );\n * const slice$ = state$.pipe(selectSlice(['title', 'items'], customComparison), tap(console.log)).subscribe();\n *\n * // displays:\n * // { title: 'myTitle', items: ['foo', 'bar'] }\n * // { title: 'nextTitle', items: ['foo', 'baR'] }\n * // { title: 'nextTitle', items: ['fooRz', 'boo'] }\n *\n * @param {(K)[]} keys - the array of keys which should be selected\n * @param {KeyCompareMap<{ [P in K]: T[P] }>} [keyCompareMap] Optional KeyCompareMap to provide custom compare logic\n * for some the keys\n * @docsPage selectSlice\n * @docsCategory operators\n */\nexport function selectSlice<T extends object, K extends keyof T>(\n  keys: K[],\n  keyCompareMap?: KeyCompareMap<{ [P in K]: T[P] }>\n): OperatorFunction<T, PickSlice<T, K>> {\n  return (o$: Observable<T>): Observable<PickSlice<T, K>> =>\n    o$.pipe(\n      filter((state) => state !== undefined),\n      map((state) => {\n        // forward null\n        if (state === null) {\n          return null;\n        }\n        // an array of all keys which exist and are _defined_ in the state object\n        const definedKeys = keys\n          // filter out undefined properties e. g. {}, { str: undefined }\n          .filter((k) => state.hasOwnProperty(k) && state[k] !== undefined);\n\n        // we want to ensure to only emit _valid_ selections\n        // a selection is _valid_ if every selected key exists and has a value:\n\n        // {} => selectSlice(['foo']) => no emission\n        // {str: 'test'} => selectSlice([]) => no emission\n        // {str: 'test'} => selectSlice(['notPresent']) => no emission\n        // {str: 'test'} => state.select(selectSlice([])) => no emission\n        // {str: 'test'} => state.select(selectSlice(['notPresent'])) => no emission\n        // {str: undefined} => state.select(selectSlice(['str'])) => no emission\n        // {str: 'test', foo: undefined } => state.select(selectSlice(['foo'])) => no emission\n        if (definedKeys.length < keys.length) {\n          return undefined;\n        }\n\n        // create the selected slice\n        return definedKeys\n          .reduce((vm, key) => {\n            vm[key] = state[key];\n            return vm;\n          }, {} as PickSlice<T, K>);\n      }),\n      filter((v) => v !== undefined),\n      distinctUntilSomeChanged(keys, keyCompareMap)\n    );\n}\n\n","import { MonoTypeOperatorFunction, Observable, OperatorFunction } from 'rxjs';\nimport { map, pluck } from 'rxjs/operators';\nimport { KeyCompareMap, PickSlice } from '../interfaces';\nimport {\n  isOperateFnArrayGuard,\n  isStringAndFunctionTupleGuard,\n  isStringArrayFunctionAndOptionalObjectTupleGuard,\n  isStringArrayGuard,\n} from '../utils/guards';\nimport { pipeFromArray } from '../utils/pipe-from-array';\nimport { selectSlice } from './selectSlice';\nimport { stateful } from './stateful';\n\n/**\n * @description\n * Returns the state as shared, replayed and distinct `Observable<T>`. This way you don't have to think about late\n * subscribers, multiple subscribers or multiple emissions of the same value.\n *\n * @example\n * const state$ = state.pipe(select());\n * state$.subscribe(state => doStuff(state));\n *\n * @returns Observable<T>\n */\n\nexport function select<T>(): MonoTypeOperatorFunction<T>;\n\n/**\n * @description\n * Returns the state as cached and distinct `Observable<A>`. Accepts arbitrary\n * [rxjs operators](https://rxjs-dev.firebaseapp.com/guide/operators) to enrich the selection with reactive composition.\n *\n * @example\n * const profilePicture$ = state.pipe(\n *   select(\n *    pluck('profilePicture'),\n *    switchMap(profilePicture => mapImageAsync(profilePicture))\n *   )\n * );\n * @param  { OperatorFunction<T, A> } op\n * @returns Observable<A>\n *\n * @docsPage select\n * @docsCategory operators\n */\nexport function select<T, A>(\n  op: OperatorFunction<T, A>\n): OperatorFunction<T, A>;\n/**\n * @internal\n */\nexport function select<T, A, B>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>\n): OperatorFunction<T, B>;\n/**\n * @internal\n */\nexport function select<T, A, B, C>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>\n): OperatorFunction<T, C>;\n/**\n * @internal\n */\nexport function select<T, A, B, C, D>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>\n): OperatorFunction<T, D>;\n/**\n * @internal\n */\nexport function select<T, A, B, C, D, E>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>,\n  op5: OperatorFunction<D, E>\n): OperatorFunction<T, E>;\n\n/**\n * @description\n * Transform a slice of the state by providing keys and map function.\n * Returns result of applying function to state slice as cached and distinct `Observable<R>`.\n *\n * @example\n * // Project state slice\n * const text$ = state$.pipe(\n *   select(\n *     ['query', 'results'],\n *     ({ query, results }) => `${results.length} results found for \"${query}\"`\n *   )\n * );\n *\n * @return Observable<R>\n */\nexport function select<T extends object, K extends keyof T, R>(\n  keys: K[],\n  fn: (slice: PickSlice<T, K>) => R,\n  keyCompareMap?: KeyCompareMap<Pick<T, K>>\n): OperatorFunction<T, R>;\n\n/**\n * @description\n * Transform a single property of the state by providing a key and map function.\n * Returns result of applying function to state property as cached and distinct `Observable<T[R]>`.\n *\n * @example\n * // Project state based on single property\n * const foo$ = state$.pipe(select('bar', bar => `bar equals ${bar}`));\n *\n * @return Observable<R>\n */\nexport function select<T, K extends keyof T, R>(\n  k: K,\n  fn: (val: T[K]) => R\n): OperatorFunction<T, R>;\n\n/**\n * @description\n * Access a single property of the state by providing keys.\n * Returns a single property of the state as cached and distinct `Observable<T[K1]>`.\n *\n * @example\n * // Access a single property\n * const bar$ = state$.pipe(select('bar'));\n *\n * // Access a nested property\n * const foo$ = state$.pipe(select('bar', 'foo'));\n *\n * @return Observable<T[K1]>\n */\nexport function select<T, K1 extends keyof T>(\n  k1: K1\n): OperatorFunction<T, T[K1]>;\n/**\n * @internal\n */\nexport function select<T, K1 extends keyof T, K2 extends keyof T[K1]>(\n  k1: K1,\n  k2: K2\n): OperatorFunction<T, T[K1][K2]>;\n/**\n * @internal\n */\nexport function select<\n  T,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2]\n>(k1: K1, k2: K2, k3: K3): OperatorFunction<T, T[K1][K2][K3]>;\n/**\n * @internal\n */\nexport function select<\n  T,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3]\n>(k1: K1, k2: K2, k3: K3, k4: K4): OperatorFunction<T, T[K1][K2][K3][K4]>;\n/**\n * @internal\n */\nexport function select<\n  T,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n  K5 extends keyof T[K1][K2][K3][K4]\n>(\n  k1: K1,\n  k2: K2,\n  k3: K3,\n  k4: K4,\n  k5: K5\n): OperatorFunction<T, T[K1][K2][K3][K4][K5]>;\n/**\n * @internal\n */\nexport function select<\n  T,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n  K5 extends keyof T[K1][K2][K3][K4],\n  K6 extends keyof T[K1][K2][K3][K4][K5]\n>(\n  k1: K1,\n  k2: K2,\n  k3: K3,\n  k4: K4,\n  k5: K5,\n  k6: K6\n): OperatorFunction<T, T[K1][K2][K3][K4][K5][K6]>;\n\n/**\n * @internal\n */\nexport function select<T extends Record<string, unknown>>(\n  ...opOrMapFn:\n    | OperatorFunction<T, unknown>[]\n    | string[]\n    | [k: string, fn: (val: unknown) => unknown]\n    | [\n        keys: string[],\n        fn: (slice: unknown) => unknown,\n        keyCompareMap?: KeyCompareMap<T>\n      ]\n): OperatorFunction<T, unknown> {\n  return (state$: Observable<T>) => {\n    if (!opOrMapFn || opOrMapFn.length === 0) {\n      return state$.pipe(stateful());\n    } else if (isStringAndFunctionTupleGuard(opOrMapFn)) {\n      return state$.pipe(stateful(map((s) => opOrMapFn[1](s[opOrMapFn[0]]))));\n    } else if (isStringArrayFunctionAndOptionalObjectTupleGuard(opOrMapFn)) {\n      return state$.pipe(\n        selectSlice<T & object, keyof T>(\n          opOrMapFn[0] as (keyof T)[],\n          opOrMapFn[2]\n        ),\n        stateful(map(opOrMapFn[1]))\n      );\n    } else if (isStringArrayGuard(opOrMapFn)) {\n      return state$.pipe(stateful(pluck(...opOrMapFn)));\n    } else if (isOperateFnArrayGuard(opOrMapFn)) {\n      return state$.pipe(stateful(pipeFromArray(opOrMapFn)));\n    } else {\n      throw new Error('wrong params passed to select');\n    }\n  };\n}\n","import { merge, Observable, queueScheduler, Subject, Subscribable, Subscription } from 'rxjs';\nimport { mergeAll, observeOn } from 'rxjs/operators';\n\nexport function createSideEffectObservable<T>(\n  stateObservables = new Subject<Observable<T>>()\n): {\n  effects$: Observable<T>;\n  nextEffectObservable: (effect$: Observable<T>) => void;\n  subscribe: () => Subscription;\n} & Subscribable<T> {\n  const effects$: Observable<T> = merge(\n    stateObservables.pipe(mergeAll(), observeOn(queueScheduler))\n  );\n\n  function nextEffectObservable(effect$: Observable<T>): void {\n    stateObservables.next(effect$);\n  }\n\n  function subscribe(): Subscription {\n    return effects$.subscribe();\n  }\n\n  return {\n    effects$,\n    nextEffectObservable,\n    subscribe\n  };\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}