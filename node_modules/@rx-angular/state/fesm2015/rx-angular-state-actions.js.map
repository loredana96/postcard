{"version":3,"file":"rx-angular-state-actions.js","sources":["../../../../libs/state/actions/src/lib/proxy.ts","../../../../libs/state/actions/src/lib/actions.factory.ts","../../../../libs/state/actions/src/lib/transforms.ts","../../../../libs/state/actions/src/rx-angular-state-actions.ts"],"sourcesContent":["/**\n * @internal\n * Internal helper to create the proxy object\n * It lifes as standalone function because we dont need to carrie it in memory for every ActionHandler instance\n * @param subjects\n * @param transforms\n */\nimport { merge, Subject } from 'rxjs';\nimport { KeysOf, ValuesOf, RxActions } from './types';\nimport { ErrorHandler } from '@angular/core';\n\nexport function actionProxyHandler<T extends object, U>(\n  subjects: { [K in keyof T]: Subject<ValuesOf<T>> },\n  transforms?: U,\n  errorHandler?: ErrorHandler\n): ProxyHandler<RxActions<T, U>> {\n  type KeysOfT = KeysOf<T>;\n  type ValuesOfT = ValuesOf<T>;\n\n  function dispatch(value: ValuesOfT, prop: KeysOfT) {\n    subjects[prop] = subjects[prop] || new Subject<ValuesOfT>();\n    try {\n      const val =\n        transforms && (transforms as any)[prop]\n          ? (transforms as any)[prop](value)\n          : value;\n      subjects[prop].next(val);\n    } catch (err) {\n      errorHandler?.handleError(err);\n    }\n  }\n  type K = keyof T;\n  return {\n    // shorthand setter for multiple signals e.g. signals({propA: 1, propB: 2})\n    apply(_: RxActions<T, U>, __: any, props: [T]): any {\n      props.forEach((slice) =>\n        Object.entries(slice).forEach(([k, v]) =>\n          dispatch(v as any, k as any as KeysOfT)\n        )\n      );\n    },\n    get(_, property: string) {\n      const prop = property as KeysOfT;\n\n      // the user wants to get a single signal as observable\n      if (prop.toString().split('').pop() === '$') {\n        if(prop.toString().length === 1) {\n          return (props: KeysOfT[]) => merge(\n              ...props.map((k) => {\n                subjects[k] = subjects[k] || new Subject<ValuesOfT>();\n                return subjects[k];\n              })\n            );\n        }\n\n        const propName = prop.toString().slice(0, -1) as KeysOfT;\n        subjects[propName] = subjects[propName] || new Subject<ValuesOfT>();\n        return subjects[propName];\n      }\n\n      // the user wants to get a dispatcher function\n      return (args: ValuesOfT) => {\n        dispatch(args, prop);\n      };\n    },\n    set() {\n      throw new Error('No setters available. To emit call the property name.');\n    },\n  };\n}\n","import { Actions, ActionTransforms, RxActions, ValuesOf } from './types';\nimport { ErrorHandler, Injectable, OnDestroy, Optional } from '@angular/core';\nimport { actionProxyHandler } from './proxy';\nimport { Subject } from 'rxjs';\n\ntype SubjectMap<T> = { [K in keyof T]: Subject<T[K]> };\n\n/**\n * This class creates RxActions bound to Angular's DI life-cycles. This prevents memory leaks and optionally makes the instance reusable across the app.\n * The main function here is called `create`, optionally you can also call `destroy` to complete all action channels.\n * If the instantiator gets destroyed also the actions get destroyed automatically.\n *\n * @example\n * const factory = new RxActionFactory<{search: string}>();\n * const actions = factory.create();\n * actions.search('');\n * actions.search$.subscribe();\n */\n@Injectable()\nexport class RxActionFactory<T extends Partial<Actions>> implements OnDestroy {\n  private subjects: SubjectMap<T>[] = [] as SubjectMap<T>[];\n\n  constructor(\n    @Optional()\n    private readonly errorHandler?: ErrorHandler\n  ) {}\n\n  /*\n   * Returns a object based off of the provided typing with a separate setter `[prop](value: T[K]): void` and observable stream `[prop]$: Observable<T[K]>`;\n   *\n   * { search: string } => { search$: Observable<string>, search: (value: string) => void;}\n   *\n   * @example\n   *\n   * interface UIActions {\n   *  search: string,\n   *  submit: void\n   * };\n   *\n   * const actions = new RxActionFactory<UIActions>().create();\n   *\n   * actions.search($event.target.value);\n   * actions.search$.subscribe();\n   *\n   * As it is well typed the following things would not work:\n   * actions.submit('not void'); // not void\n   * actions.search(); // requires an argument\n   * actions.search(42); // not a string\n   * actions.search$.error(new Error('traraaa')); // not possible by typings as well as in code\n   * actions.search = \"string\"; // not a setter. the proxy will throw an error pointing out that you have to call it\n   *\n   * @param transforms - A map of transform functions to apply on transformations to actions before emitting them.\n   * This is very useful to clean up bloated templates and components. e.g. `[input]=\"$event?.target?.value\"` => `[input]=\"$event\"`\n   *\n   * @example\n   * function coerceSearchActionParams(e: Event | string | number): string {\n   *   if(e?.target?.value !== undefined) {\n   *      return e?.target?.value + ''\n   *   }\n   *   return e + '';\n   * }\n   * const actions = getActions<search: string, submit: void>({search: coerceSearchActionParams, submit: (v: any) => void 0;});\n   *\n   * actions.search($event);\n   * actions.search('string');\n   * actions.search(42);\n   * actions.submit('not void'); // does not error anymore\n   * actions.search$.subscribe(); // string Observable\n   *\n   */\n  create<U extends ActionTransforms<T> = {}>(transforms?: U): RxActions<T, U> {\n    const subjects: SubjectMap<T> = {} as SubjectMap<T>;\n    this.subjects.push(subjects);\n\n    function signals(): void {}\n    return new Proxy(\n      signals as any as RxActions<T, U>,\n      actionProxyHandler(\n        subjects as any as { [K in keyof T]: Subject<ValuesOf<T>> },\n        transforms,\n        this.errorHandler\n      )\n    ) as any as RxActions<T, U>;\n  }\n\n  destroy() {\n    this.subjects.forEach((s) => {\n      Object.values(s).forEach((subject: any) => subject.complete());\n    })\n  }\n\n  /**\n   * @internal\n   * Internally used to clean up potential subscriptions to the subjects. (For Actions it is most probably a rare case but still important to care about)\n   */\n  ngOnDestroy() {\n    this.destroy();\n  }\n}\n","/**\n * @description\n * This transform is a side effecting operation applying `preventDefault` to a passed Event\n * @param e\n */\nexport function preventDefault(e: Event): Event {\n  e.preventDefault();\n  return e;\n}\n\n/**\n * @description\n * This transform is a side effecting operation applying `stopPropagation` to a passed Event\n * @param e\n */\nexport function stopPropagation(e: Event): Event {\n  e.stopPropagation();\n  return e;\n}\n\n/**\n * @description\n * This transform is a side effecting operation applying `preventDefault` and `stopPropagation` to a passed Event\n * @param e\n */\nexport function preventDefaultStopPropagation(e: Event): Event {\n  e.stopPropagation();\n  e.preventDefault();\n  return e;\n}\n\n\n/**\n * @description\n * This transform is helps to pluck values from DOM `Event` or forward the value directly.\n * @param e\n */\nexport function eventValue<T = string>(e: Event | T): T {\n  // Consider https://stackoverflow.com/questions/1458894/how-to-determine-if-javascript-object-is-an-event\n  if((e as unknown as {target: {value: T}})?.target) {\n    return (e as unknown as {target: {value: T}})?.target?.value;\n  }\n  return e as T;\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}