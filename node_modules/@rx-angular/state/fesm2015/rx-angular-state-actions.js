import * as i0 from '@angular/core';
import { Injectable, Optional } from '@angular/core';
import { Subject, merge } from 'rxjs';

/**
 * @internal
 * Internal helper to create the proxy object
 * It lifes as standalone function because we dont need to carrie it in memory for every ActionHandler instance
 * @param subjects
 * @param transforms
 */
function actionProxyHandler(subjects, transforms, errorHandler) {
    function dispatch(value, prop) {
        subjects[prop] = subjects[prop] || new Subject();
        try {
            const val = transforms && transforms[prop]
                ? transforms[prop](value)
                : value;
            subjects[prop].next(val);
        }
        catch (err) {
            errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler.handleError(err);
        }
    }
    return {
        // shorthand setter for multiple signals e.g. signals({propA: 1, propB: 2})
        apply(_, __, props) {
            props.forEach((slice) => Object.entries(slice).forEach(([k, v]) => dispatch(v, k)));
        },
        get(_, property) {
            const prop = property;
            // the user wants to get a single signal as observable
            if (prop.toString().split('').pop() === '$') {
                if (prop.toString().length === 1) {
                    return (props) => merge(...props.map((k) => {
                        subjects[k] = subjects[k] || new Subject();
                        return subjects[k];
                    }));
                }
                const propName = prop.toString().slice(0, -1);
                subjects[propName] = subjects[propName] || new Subject();
                return subjects[propName];
            }
            // the user wants to get a dispatcher function
            return (args) => {
                dispatch(args, prop);
            };
        },
        set() {
            throw new Error('No setters available. To emit call the property name.');
        },
    };
}

/**
 * This class creates RxActions bound to Angular's DI life-cycles. This prevents memory leaks and optionally makes the instance reusable across the app.
 * The main function here is called `create`, optionally you can also call `destroy` to complete all action channels.
 * If the instantiator gets destroyed also the actions get destroyed automatically.
 *
 * @example
 * const factory = new RxActionFactory<{search: string}>();
 * const actions = factory.create();
 * actions.search('');
 * actions.search$.subscribe();
 */
class RxActionFactory {
    constructor(errorHandler) {
        this.errorHandler = errorHandler;
        this.subjects = [];
    }
    /*
     * Returns a object based off of the provided typing with a separate setter `[prop](value: T[K]): void` and observable stream `[prop]$: Observable<T[K]>`;
     *
     * { search: string } => { search$: Observable<string>, search: (value: string) => void;}
     *
     * @example
     *
     * interface UIActions {
     *  search: string,
     *  submit: void
     * };
     *
     * const actions = new RxActionFactory<UIActions>().create();
     *
     * actions.search($event.target.value);
     * actions.search$.subscribe();
     *
     * As it is well typed the following things would not work:
     * actions.submit('not void'); // not void
     * actions.search(); // requires an argument
     * actions.search(42); // not a string
     * actions.search$.error(new Error('traraaa')); // not possible by typings as well as in code
     * actions.search = "string"; // not a setter. the proxy will throw an error pointing out that you have to call it
     *
     * @param transforms - A map of transform functions to apply on transformations to actions before emitting them.
     * This is very useful to clean up bloated templates and components. e.g. `[input]="$event?.target?.value"` => `[input]="$event"`
     *
     * @example
     * function coerceSearchActionParams(e: Event | string | number): string {
     *   if(e?.target?.value !== undefined) {
     *      return e?.target?.value + ''
     *   }
     *   return e + '';
     * }
     * const actions = getActions<search: string, submit: void>({search: coerceSearchActionParams, submit: (v: any) => void 0;});
     *
     * actions.search($event);
     * actions.search('string');
     * actions.search(42);
     * actions.submit('not void'); // does not error anymore
     * actions.search$.subscribe(); // string Observable
     *
     */
    create(transforms) {
        const subjects = {};
        this.subjects.push(subjects);
        function signals() { }
        return new Proxy(signals, actionProxyHandler(subjects, transforms, this.errorHandler));
    }
    destroy() {
        this.subjects.forEach((s) => {
            Object.values(s).forEach((subject) => subject.complete());
        });
    }
    /**
     * @internal
     * Internally used to clean up potential subscriptions to the subjects. (For Actions it is most probably a rare case but still important to care about)
     */
    ngOnDestroy() {
        this.destroy();
    }
}
/** @nocollapse */ RxActionFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: RxActionFactory, deps: [{ token: i0.ErrorHandler, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ RxActionFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: RxActionFactory });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: RxActionFactory, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.ErrorHandler, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * @description
 * This transform is a side effecting operation applying `preventDefault` to a passed Event
 * @param e
 */
function preventDefault(e) {
    e.preventDefault();
    return e;
}
/**
 * @description
 * This transform is a side effecting operation applying `stopPropagation` to a passed Event
 * @param e
 */
function stopPropagation(e) {
    e.stopPropagation();
    return e;
}
/**
 * @description
 * This transform is a side effecting operation applying `preventDefault` and `stopPropagation` to a passed Event
 * @param e
 */
function preventDefaultStopPropagation(e) {
    e.stopPropagation();
    e.preventDefault();
    return e;
}
/**
 * @description
 * This transform is helps to pluck values from DOM `Event` or forward the value directly.
 * @param e
 */
function eventValue(e) {
    var _a, _b, _c;
    // Consider https://stackoverflow.com/questions/1458894/how-to-determine-if-javascript-object-is-an-event
    if ((_a = e) === null || _a === void 0 ? void 0 : _a.target) {
        return (_c = (_b = e) === null || _b === void 0 ? void 0 : _b.target) === null || _c === void 0 ? void 0 : _c.value;
    }
    return e;
}

/**
 * Generated bundle index. Do not edit.
 */

export { RxActionFactory, eventValue, preventDefault, preventDefaultStopPropagation, stopPropagation };
//# sourceMappingURL=rx-angular-state-actions.js.map
