import * as i0 from '@angular/core';
import { Injectable, Optional } from '@angular/core';
import { Subject, Subscription, pipe, from, EMPTY } from 'rxjs';
import { filter, take, shareReplay, pluck, takeUntil, mergeAll, share, mapTo, tap, catchError } from 'rxjs/operators';

function isSingleShotHookNameGuard(name) {
    return !!name && typeof name === 'string' && name !== '';
}
/**
 * @internal
 * Operator to filter values for single shot observables
 */
const singleShotOperators = (o$) => o$.pipe(filter((v) => v === true), take(1), shareReplay());
/**
 * This is an operator that is used to listen to Angular lifecycle hooks.
 * It plucks a defined lefe cycle name `HookProps` and forwards values for the particular value and in the behavior of the hook e.g. single shot
 *
 * @param name
 */
function toHook(name) {
    const operators = isSingleShotHookNameGuard(name)
        ? singleShotOperators
        : (o) => o;
    return (o$) => o$.pipe(pluck(name), operators);
}
/**
 * This operator can be used to take instances that implements `OnDestroy$` and unsubscribes from the given Observable when the instances
 * `onDestroy$` Observable emits.
 *
 * @param instanceWithLifecycle
 */
function untilDestroyed(instanceWithLifecycle) {
    return (source) => source.pipe(takeUntil(instanceWithLifecycle.onDestroy$));
}

/**
 * Reduces subscription boilerplate for performing observable-based side-effects in components.
 *
 * Before:
 * ```ts
 * @Component({
 *   // ...
 * })
 * export class FooComponent implements OnDestroy {
 *   private readonly destroy$ = new Subject<void>();
 *
 *   constructor() {
 *     obs$.pipe(takeUntil(this.destroy$)).subscribe(doSideEffect);
 *   }
 *
 *   ngOnDestroy(): void {
 *     this.destroy$.next();
 *     this.destroy$.complete();
 *   }
 * }
 * ```
 *
 * After:
 * ```ts
 * @Component({
 *   // ...
 *   providers: [RxEffects],
 * })
 * export class FooComponent {
 *   constructor(effects: RxEffects) {
 *     effects.register(obs$, doSideEffect);
 *     // OR
 *     effects.register(obs$.pipe(tap(doSideEffect)));
 *     // OR
 *     effects.register(obs$.subscribe(doSideEffect));
 *   }
 * }
 * ```
 *
 * NOTE: Avoid calling register/unregister/subscribe inside the side-effect function.
 */
class RxEffects {
    constructor(errorHandler) {
        this.errorHandler = errorHandler;
        this._hooks$ = new Subject();
        this.observables$ = new Subject();
        // we have to use publish here to make it hot (composition happens without subscriber)
        this.effects$ = this.observables$.pipe(mergeAll(), share());
        this.subscription = this.effects$.subscribe();
        this.onDestroy$ = this._hooks$.pipe(toHook('destroy'));
        this.destroyers = {};
    }
    register(obsOrSub, fnOrObj) {
        if (obsOrSub instanceof Subscription) {
            this.subscription.add(obsOrSub);
            return;
        }
        const effectId = RxEffects.nextId++;
        const destroy$ = (this.destroyers[effectId] = new Subject());
        const applyBehavior = pipe(mapTo(effectId), takeUntil(destroy$));
        if (fnOrObj != null) {
            this.observables$.next(from(obsOrSub).pipe(
            // ternary expression is to help Typescript infer overloads
            typeof fnOrObj === 'function' ? tap(fnOrObj) : tap(fnOrObj), catchError((err) => {
                var _a;
                (_a = this.errorHandler) === null || _a === void 0 ? void 0 : _a.handleError(err);
                return EMPTY;
            }), applyBehavior));
        }
        else {
            this.observables$.next(from(obsOrSub).pipe(applyBehavior));
        }
        return effectId;
    }
    /**
     * Imperatively cancel a side-effect while the component is still running.
     *
     * Note that all effects are automatically cancelled when a component is destroyed,
     * so you most often won't need to call this method.
     * @param effectId Effect ID (returned by register method)
     */
    unregister(effectId) {
        var _a;
        (_a = this.destroyers[effectId]) === null || _a === void 0 ? void 0 : _a.next();
    }
    /**
     * Fires a sideEffect when the instances `OnDestroy` hook is fired.
     *
     * @example
     * effects.registerOnDestroy(mode => localStorage.setItem('colorMode', mode));
     *
     * @param sideEffect
     */
    registerOnDestroy(sideEffect) {
        return this.register(this.onDestroy$, sideEffect);
    }
    /**
     * Operator that unsubscribes based on emission of an registered effect.
     *
     * @NOTICE
     * This operator has to be placed always at the end of the operator chain (before the subscription).
     * Otherwise we may leak as a subsequent operator could instantiate new ongoing Observables which will not get unsubscribed.
     *
     * @example
     * const effectId1 = effects.register(
     *   colorMode$.subscribe(mode => localStorage.setItem('colorMode', mode))
     * );
     *
     * someValue$.pipe(
     *    effect.untilEffect(effectId1)
     * )
     *
     */
    untilEffect(effectId) {
        return (source) => source.pipe(untilDestroyed(this), takeUntil(this.effects$.pipe(filter((eId) => eId === effectId))));
    }
    /**
     * @internal
     */
    ngOnDestroy() {
        this._hooks$.next({ destroy: true });
        this.subscription.unsubscribe();
    }
}
RxEffects.nextId = 0;
/** @nocollapse */ RxEffects.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: RxEffects, deps: [{ token: i0.ErrorHandler, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ RxEffects.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: RxEffects });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: RxEffects, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.ErrorHandler, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Generated bundle index. Do not edit.
 */

export { RxEffects };
//# sourceMappingURL=state-effects.js.map
