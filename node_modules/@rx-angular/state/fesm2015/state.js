import * as i0 from '@angular/core';
import { Injectable } from '@angular/core';
import { createAccumulationObservable, createSideEffectObservable, safePluck, isKeyOf, select, isDefined, isObjectGuard } from '@rx-angular/state/selections';
export * from '@rx-angular/state/selections';
import { Subscription, isObservable, EMPTY } from 'rxjs';
import { map, catchError, tap } from 'rxjs/operators';

/**
 * @description
 * RxState is a light-weight reactive state management service for managing local state in angular.
 *
 * @example
 * Component({
 *   selector: 'app-stateful',
 *   template: `<div>{{ state$ | async | json }}</div>`,
 *   providers: [RxState]
 * })
 * export class StatefulComponent {
 *   readonly state$ = this.state.select();
 *
 *   constructor(private state: RxState<{ foo: string }>) {}
 * }
 *
 * @docsCategory RxState
 * @docsPage RxState
 */
class RxState {
    /**
     * @internal
     */
    constructor() {
        this.subscription = new Subscription();
        this.accumulator = createAccumulationObservable();
        this.effectObservable = createSideEffectObservable();
        /**
         * @description
         * The unmodified state exposed as `Observable<T>`. It is not shared, distinct or gets replayed.
         * Use the `$` property if you want to read the state without having applied {@link stateful} to it.
         */
        this.$ = this.accumulator.signal$;
        this.subscription.add(this.subscribe());
    }
    /**
     * @internal
     */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    /**
     * @description
     *
     * Allows to customize state accumulation function.
     * This can be helpful to implement deep updates and tackle other immutability problems in a custom way.
     * @example
     *
     * ```typescript
     * const myAccumulator = (state: MyState, slice: Partial<MyState>) => deepCopy(state, slice);
     *
     * this.state.setAccumulator(myAccumulator);
     * ```
     */
    setAccumulator(accumulatorFn) {
        this.accumulator.nextAccumulator(accumulatorFn);
    }
    /** @internal **/
    get(...keys) {
        const hasStateAnyKeys = Object.keys(this.accumulator.state).length > 0;
        if (!!keys && keys.length) {
            return safePluck(this.accumulator.state, keys);
        }
        else {
            return hasStateAnyKeys
                ? this.accumulator.state
                : undefined;
        }
    }
    /**
     * @internal
     */
    set(keyOrStateOrProjectState, stateOrSliceProjectFn) {
        if (typeof keyOrStateOrProjectState === 'object' &&
            stateOrSliceProjectFn === undefined) {
            this.accumulator.nextSlice(keyOrStateOrProjectState);
            return;
        }
        if (typeof keyOrStateOrProjectState === 'function' &&
            stateOrSliceProjectFn === undefined) {
            this.accumulator.nextSlice(keyOrStateOrProjectState(this.accumulator.state));
            return;
        }
        if (isKeyOf(keyOrStateOrProjectState) &&
            typeof stateOrSliceProjectFn === 'function') {
            const state = {};
            state[keyOrStateOrProjectState] = stateOrSliceProjectFn(this.accumulator.state);
            this.accumulator.nextSlice(state);
            return;
        }
        throw new Error('wrong params passed to set');
    }
    /**
     * @internal
     */
    connect(keyOrInputOrSlice$, projectOrSlices$, projectValueFn) {
        if (projectValueFn === undefined &&
            projectOrSlices$ === undefined &&
            isObservable(keyOrInputOrSlice$)) {
            this.accumulator.nextSliceObservable(keyOrInputOrSlice$);
            return;
        }
        if (projectValueFn === undefined &&
            typeof projectOrSlices$ === 'function' &&
            isObservable(keyOrInputOrSlice$) &&
            !isObservable(projectOrSlices$)) {
            const project = projectOrSlices$;
            const slice$ = keyOrInputOrSlice$.pipe(map((v) => project(this.get(), v)));
            this.accumulator.nextSliceObservable(slice$);
            return;
        }
        if (projectValueFn === undefined &&
            isKeyOf(keyOrInputOrSlice$) &&
            isObservable(projectOrSlices$)) {
            const key = keyOrInputOrSlice$;
            const slice$ = projectOrSlices$.pipe(map((value) => (Object.assign({}, { [key]: value }))));
            this.accumulator.nextSliceObservable(slice$);
            return;
        }
        if (typeof projectValueFn === 'function' &&
            isKeyOf(keyOrInputOrSlice$) &&
            isObservable(projectOrSlices$)) {
            const key = keyOrInputOrSlice$;
            const slice$ = projectOrSlices$.pipe(map((value) => (Object.assign({}, { [key]: projectValueFn(this.get(), value) }))));
            this.accumulator.nextSliceObservable(slice$);
            return;
        }
        throw new Error('wrong params passed to connect');
    }
    /**
     * @internal
     */
    select(...args) {
        return this.accumulator.state$.pipe(select(...args));
    }
    /**
     * @description
     * Manages side-effects of your state. Provide an `Observable<any>` **side-effect** and an optional
     * `sideEffectFunction`.
     * Subscription handling is done automatically.
     *
     * @example
     * // Directly pass an observable side-effect
     * const localStorageEffect$ = changes$.pipe(
     *  tap(changes => storeChanges(changes))
     * );
     * state.hold(localStorageEffect$);
     *
     * // Pass an additional `sideEffectFunction`
     *
     * const localStorageEffectFn = changes => storeChanges(changes);
     * state.hold(changes$, localStorageEffectFn);
     *
     * @param {Observable<S>} obsOrObsWithSideEffect
     * @param {function} [sideEffectFn]
     */
    hold(obsOrObsWithSideEffect, sideEffectFn) {
        const sideEffect = obsOrObsWithSideEffect.pipe(catchError((e) => EMPTY));
        if (typeof sideEffectFn === 'function') {
            this.effectObservable.nextEffectObservable(sideEffect.pipe(tap(sideEffectFn)));
            return;
        }
        this.effectObservable.nextEffectObservable(sideEffect);
    }
    /**
     * @internal
     */
    subscribe() {
        const subscription = new Subscription();
        subscription.add(this.accumulator.subscribe());
        subscription.add(this.effectObservable.subscribe());
        return subscription;
    }
}
/** @nocollapse */ RxState.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: RxState, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ RxState.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: RxState });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: RxState, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return []; } });

// eslint-disable-next-line @nrwl/nx/enforce-module-boundaries
/**
 * @deprecated moved to `@rx-angular/cdk/transformations`
 * @see {@link https://www.npmjs.com/package/@rx-angular/cdk}
 */
function insert(source, updates) {
    const updatesDefined = isDefined(updates);
    const sourceIsNotArray = !Array.isArray(source);
    const invalidInput = sourceIsNotArray && !updatesDefined;
    if (sourceIsNotArray && isDefined(source)) {
        console.warn(`Insert: Original value (${source}) is not an array.`);
    }
    if (invalidInput) {
        return source;
    }
    return (sourceIsNotArray ? [] : source).concat(updatesDefined ? (Array.isArray(updates) ? updates : [updates]) : []);
}

// eslint-disable-next-line @nrwl/nx/enforce-module-boundaries
const defaultCompareFn = (a, b) => a === b;
/**
 * @deprecated moved to `@rx-angular/cdk/transformations`
 * @see {@link https://www.npmjs.com/package/@rx-angular/cdk}
 */
function valuesComparer(original, incoming, compare) {
    if (isKeyOf(compare)) {
        return original[compare] === incoming[compare];
    }
    if (Array.isArray(compare)) {
        const sanitizedKeys = compare.filter((k) => isKeyOf(k));
        return sanitizedKeys.length > 0
            ? sanitizedKeys.every((k) => original[k] === incoming[k])
            : defaultCompareFn(original, incoming);
    }
    return (compare || defaultCompareFn)(original, incoming);
}

// eslint-disable-next-line @nrwl/nx/enforce-module-boundaries
/**
 * @deprecated moved to `@rx-angular/cdk/transformations`
 * @see {@link https://www.npmjs.com/package/@rx-angular/cdk}
 */
function remove(source, scrap, compare) {
    const scrapAsArray = isDefined(scrap)
        ? Array.isArray(scrap)
            ? scrap
            : [scrap]
        : [];
    const invalidInput = !Array.isArray(source);
    if (invalidInput) {
        console.warn(`Remove: original value (${source}) is not an array`);
        return source;
    }
    return source.filter((existingItem) => {
        return !scrapAsArray.some((item) => valuesComparer(item, existingItem, compare));
    });
}

// eslint-disable-next-line @nrwl/nx/enforce-module-boundaries
/**
 * @deprecated moved to `@rx-angular/cdk/transformations`
 * @see {@link https://www.npmjs.com/package/@rx-angular/cdk}
 */
function toDictionary(source, key) {
    if (!isDefined(source)) {
        return source;
    }
    const sourceEmpty = !source.length;
    if (!Array.isArray(source) || sourceEmpty || !isKeyOf(source[0][key])) {
        if (!sourceEmpty) {
            console.warn('ToDictionary: unexpected input params.');
        }
        return {};
    }
    const dictionary = {};
    const length = source.length;
    let i = 0;
    for (i; i < length; i++) {
        dictionary[`${source[i][key]}`] = Object.assign({}, source[i]);
    }
    return dictionary;
}

/**
 * @deprecated moved to `@rx-angular/cdk/transformations`
 * @see {@link https://www.npmjs.com/package/@rx-angular/cdk}
 */
function update(source, updates, compare) {
    const updatesDefined = updates != null;
    const updatesAsArray = updatesDefined
        ? Array.isArray(updates)
            ? updates
            : [updates]
        : [];
    const sourceDefined = source != null;
    const sourceIsNotArray = !Array.isArray(source);
    const invalidInput = sourceIsNotArray || source.length === 0 || updatesAsArray.length === 0;
    if (sourceDefined && sourceIsNotArray) {
        console.warn(`Update: Original value (${source}) is not an array.`);
    }
    if (invalidInput) {
        return source;
    }
    const x = [];
    for (const existingItem of source) {
        const match = customFind(updatesAsArray, (item) => valuesComparer(item, existingItem, compare));
        x.push(match ? Object.assign(Object.assign({}, existingItem), match) : existingItem);
    }
    return x;
}
function customFind(array, fn) {
    for (const item of array) {
        const x = fn(item);
        if (x) {
            return item;
        }
    }
}

// eslint-disable-next-line @nrwl/nx/enforce-module-boundaries
/**
 * @deprecated moved to `@rx-angular/cdk/transformations`
 * @see {@link https://www.npmjs.com/package/@rx-angular/cdk}
 */
function extract(array, keys) {
    const arrayIsArray = isDefined(array) && Array.isArray(array);
    if (!arrayIsArray) {
        console.warn(`extract: original value (${array}) is not an array.`);
        return undefined;
    }
    const sanitizedKeys = (Array.isArray(keys) ? keys : [keys]).filter((k) => isKeyOf(k) && array.some((i) => k in i));
    const length = sanitizedKeys.length;
    if (!sanitizedKeys.length) {
        console.warn(`extract: provided keys not found`);
        return undefined;
    }
    return array.map((item) => {
        let i = 0;
        const result = {};
        for (i; i < length; i++) {
            result[sanitizedKeys[i]] = item[sanitizedKeys[i]];
        }
        return result;
    });
}

// eslint-disable-next-line @nrwl/nx/enforce-module-boundaries
/**
 * @deprecated moved to `@rx-angular/cdk/transformations`
 * @see {@link https://www.npmjs.com/package/@rx-angular/cdk}
 */
function upsert(source, update, compare) {
    // check inputs for validity
    const updatesAsArray = update != null ? (Array.isArray(update) ? update : [update]) : [];
    // check inputs for validity
    const sourceIsNotArray = !Array.isArray(source);
    const invalidInput = sourceIsNotArray && updatesAsArray.length === 0;
    // if the source value is not an Array or the input is not defined return the original source
    // this is the case for any edge case:
    // '', null, undefined, CustomObjectOfDoomAndDarkness, ...
    if (invalidInput) {
        return source;
    }
    // if source is empty array or not an array, but the updates are valid:
    // return a shallow copy of the updates as result
    if (updatesAsArray.length > 0 && (sourceIsNotArray || source.length === 0)) {
        return [...updatesAsArray];
    }
    const inserts = [];
    const updates = {};
    // process updates/inserts
    for (const item of updatesAsArray) {
        const match = source.findIndex((sourceItem) => valuesComparer(item, sourceItem, compare));
        // if item already exists, save it as update
        if (match !== -1) {
            updates[match] = item;
        }
        else {
            // otherwise consider this as insert
            if (isObjectGuard(item)) {
                // create a shallow copy if item is an object
                inserts.push(Object.assign({}, item));
            }
            else {
                // otherwise just push it
                inserts.push(item);
            }
        }
    }
    const updated = source.map((item, i) => {
        const updatedItem = updates[i];
        // process the updated
        if (updatedItem !== null && updatedItem !== undefined) {
            if (isObjectGuard(item)) {
                return Object.assign(Object.assign({}, item), updatedItem);
            }
            else {
                return updatedItem;
            }
        }
        return item;
    });
    // return the combination of the updated source & the inserts as new array
    return updated.concat(inserts);
}

// eslint-disable-next-line @nrwl/nx/enforce-module-boundaries
/**
 * @deprecated moved to `@rx-angular/cdk/transformations`
 * @see {@link https://www.npmjs.com/package/@rx-angular/cdk}
 */
function deleteProp(object, key) {
    if (!isDefined(object) || !isObjectGuard(object)) {
        console.warn(`DeleteProp: original value ${object} is not an object.`);
        return object;
    }
    if (!isKeyOf(key)) {
        console.warn(`DeleteProp: provided key is not a string, number or symbol.`);
        return Object.assign({}, object);
    }
    const copy = Object.assign({}, object);
    delete copy[key];
    return copy;
}

// eslint-disable-next-line @nrwl/nx/enforce-module-boundaries
/**
 * @deprecated moved to `@rx-angular/cdk/transformations`
 * @see {@link https://www.npmjs.com/package/@rx-angular/cdk}
 */
function dictionaryToArray(dictionary) {
    if (!isDefined(dictionary)) {
        return dictionary;
    }
    if (!isObjectGuard(dictionary)) {
        console.warn(`DictionaryToArray: unexpected input.`);
        return [];
    }
    return Object.values(dictionary);
}

// eslint-disable-next-line @nrwl/nx/enforce-module-boundaries
/**
 * @deprecated moved to `@rx-angular/cdk/transformations`
 * @see {@link https://www.npmjs.com/package/@rx-angular/cdk}
 */
function patch(object, upd) {
    const update = isObjectGuard(upd) ? upd : {};
    if (!isObjectGuard(object) && isObjectGuard(upd)) {
        console.warn(`Patch: original value ${object} is not an object.`);
        return Object.assign({}, update);
    }
    if (!isObjectGuard(object) && !isObjectGuard(upd)) {
        console.warn(`Patch: original value ${object} and updates ${upd} are not objects.`);
        return object;
    }
    return Object.assign(Object.assign({}, object), update);
}

// eslint-disable-next-line @nrwl/nx/enforce-module-boundaries
/**
 * @deprecated moved to `@rx-angular/cdk/transformations`
 * @see {@link https://www.npmjs.com/package/@rx-angular/cdk}
 */
function setProp(object, key, value) {
    const objectIsObject = isObjectGuard(object);
    const keyIsValid = isKeyOf(key);
    const initialObject = objectIsObject ? object : {};
    if (!objectIsObject) {
        console.warn(`SetProp: original value (${object}) is not an object.`);
    }
    if (!keyIsValid) {
        console.warn(`SetProp: key argument (${key}) is invalid.`);
    }
    if (!isDefined(object) && !keyIsValid) {
        return object;
    }
    if (keyIsValid) {
        return Object.assign(Object.assign({}, initialObject), { [key]: value });
    }
    return Object.assign({}, initialObject);
}

// eslint-disable-next-line @nrwl/nx/enforce-module-boundaries
/**
 * @deprecated moved to `@rx-angular/cdk/transformations`
 * @see {@link https://www.npmjs.com/package/@rx-angular/cdk}
 */
function toggle(object, key) {
    const objectIsObject = isObjectGuard(object);
    const keyIsValid = isKeyOf(key);
    const initialObject = objectIsObject ? object : {};
    if (!objectIsObject) {
        console.warn(`Toggle: original value (${object}) is not an object.`);
    }
    if (!keyIsValid) {
        console.warn(`Toggle: key argument (${key}) is invalid.`);
    }
    if (keyIsValid && typeof initialObject[key] !== 'boolean') {
        console.warn(`Toggle: value of the key (${key}) is not a boolean.`);
    }
    if (!isDefined(object) && !keyIsValid) {
        return object;
    }
    if (keyIsValid &&
        (typeof initialObject[key] === 'boolean' ||
            !initialObject.hasOwnProperty(key))) {
        return Object.assign(Object.assign({}, initialObject), { [key]: !initialObject[key] });
    }
    return Object.assign({}, initialObject);
}

// eslint-disable-next-line @nrwl/nx/enforce-module-boundaries
/**
 * @deprecated moved to `@rx-angular/cdk/transformations`
 * @see {@link https://www.npmjs.com/package/@rx-angular/cdk}
 */
function slice(object, keys) {
    const objectIsObject = isDefined(object) && isObjectGuard(object);
    if (!objectIsObject) {
        console.warn(`slice: original value (${object}) is not an object.`);
        return undefined;
    }
    const sanitizedKeys = (Array.isArray(keys) ? keys : [keys]).filter((k) => isKeyOf(k) && k in object);
    if (!sanitizedKeys.length) {
        console.warn(`slice: provided keys not found`);
        return undefined;
    }
    return sanitizedKeys.reduce((acc, k) => (Object.assign(Object.assign({}, acc), { [k]: object[k] })), {});
}

/**
 * Generated bundle index. Do not edit.
 */

export { RxState, deleteProp, dictionaryToArray, extract, insert, patch, remove, setProp, slice, toDictionary, toggle, update, upsert };
//# sourceMappingURL=state.js.map
