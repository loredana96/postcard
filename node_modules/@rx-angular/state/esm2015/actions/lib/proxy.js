/**
 * @internal
 * Internal helper to create the proxy object
 * It lifes as standalone function because we dont need to carrie it in memory for every ActionHandler instance
 * @param subjects
 * @param transforms
 */
import { merge, Subject } from 'rxjs';
export function actionProxyHandler(subjects, transforms, errorHandler) {
    function dispatch(value, prop) {
        subjects[prop] = subjects[prop] || new Subject();
        try {
            const val = transforms && transforms[prop]
                ? transforms[prop](value)
                : value;
            subjects[prop].next(val);
        }
        catch (err) {
            errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler.handleError(err);
        }
    }
    return {
        // shorthand setter for multiple signals e.g. signals({propA: 1, propB: 2})
        apply(_, __, props) {
            props.forEach((slice) => Object.entries(slice).forEach(([k, v]) => dispatch(v, k)));
        },
        get(_, property) {
            const prop = property;
            // the user wants to get a single signal as observable
            if (prop.toString().split('').pop() === '$') {
                if (prop.toString().length === 1) {
                    return (props) => merge(...props.map((k) => {
                        subjects[k] = subjects[k] || new Subject();
                        return subjects[k];
                    }));
                }
                const propName = prop.toString().slice(0, -1);
                subjects[propName] = subjects[propName] || new Subject();
                return subjects[propName];
            }
            // the user wants to get a dispatcher function
            return (args) => {
                dispatch(args, prop);
            };
        },
        set() {
            throw new Error('No setters available. To emit call the property name.');
        },
    };
}
//# sourceMappingURL=proxy.js.map