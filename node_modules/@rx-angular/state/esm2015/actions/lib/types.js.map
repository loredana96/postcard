{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../../../../libs/state/actions/src/lib/types.ts"],"names":[],"mappings":"","sourcesContent":["import { Observable } from 'rxjs';\n\nexport type ValuesOf<O> = O[keyof O];\n// type Keys = KeysOf<{ a: string, b: number }>; // \"a\" | \"b\"\nexport type KeysOf<O> = keyof O;\n\n// class vs instance\ntype InstanceOrType<T> = T extends abstract new (...args: any) => infer R ? R : T;\n\n// We infer all arguments instead of just the first one as we are more flexible for later changes\ntype InferArguments<T> = T extends (...args: infer R) => any ? R : never;\n\n// It helps to infer the type of an objects key\n// We have to use it because using just U[K] directly would @TODO\ntype Select<U, K> = K extends keyof U ? U[K] : never;\n\ntype ExtractString<T extends object> = Extract<keyof T, string>;\n\n// Helper to get either the params of the transform function, or if the function is not present a fallback type\ntype FunctionParamsOrValueType<U, K, F> = InferArguments<Select<U, K>> extends never\n  ? [F]\n  : InferArguments<Select<U, K>>;\n\nexport type Actions = {};\n\nexport type ActionTransforms<T extends {}> = Partial<{\n  [K in keyof T]: (...args: any[]) => T[K];\n}>;\n\nexport type ActionDispatchFn<O extends unknown[]> = (\n  ...value: InstanceOrType<O>\n) => void;\n\nexport type ActionDispatchers<T extends Actions, U extends {}> = {\n  [K in keyof T]: ActionDispatchFn<FunctionParamsOrValueType<U, K, Select<T, K>>>;\n};\n\nexport type ActionObservables<T extends Actions> = {\n  [K in ExtractString<T> as `${K}$`]: Observable<InstanceOrType<T[K]>>;\n};\n\nexport type RxActions<T extends Actions, U extends {} = T> = ActionDispatchers<T, U> &\n  ActionObservables<T> &\n  ((slice: Partial<T>) => void) &\n  {$:(props: (keyof T)[]) => Observable<ValuesOf<T>>};\n"]}