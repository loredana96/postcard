{"version":3,"file":"actions.factory.js","sourceRoot":"","sources":["../../../../../../libs/state/actions/src/lib/actions.factory.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,YAAY,EAAE,UAAU,EAAa,QAAQ,EAAE,MAAM,eAAe,CAAC;AAC9E,OAAO,EAAE,kBAAkB,EAAE,MAAM,SAAS,CAAC;;AAK7C;;;;;;;;;;GAUG;AAEH,MAAM,OAAO,eAAe;IAG1B,YAEmB,YAA2B;QAA3B,iBAAY,GAAZ,YAAY,CAAe;QAJtC,aAAQ,GAAoB,EAAqB,CAAC;IAKvD,CAAC;IAEJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OA0CG;IACH,MAAM,CAAqC,UAAc;QACvD,MAAM,QAAQ,GAAkB,EAAmB,CAAC;QACpD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAE7B,SAAS,OAAO,KAAU,CAAC;QAC3B,OAAO,IAAI,KAAK,CACd,OAAiC,EACjC,kBAAkB,CAChB,QAA2D,EAC3D,UAAU,EACV,IAAI,CAAC,YAAY,CAClB,CACwB,CAAC;IAC9B,CAAC;IAED,OAAO;QACL,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE;YAC1B,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,OAAY,EAAE,EAAE,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC,CAAC;QACjE,CAAC,CAAC,CAAA;IACJ,CAAC;IAED;;;OAGG;IACH,WAAW;QACT,IAAI,CAAC,OAAO,EAAE,CAAC;IACjB,CAAC;;gIA9EU,eAAe;oIAAf,eAAe;4FAAf,eAAe;kBAD3B,UAAU;;0BAKN,QAAQ","sourcesContent":["import { Actions, ActionTransforms, RxActions, ValuesOf } from './types';\nimport { ErrorHandler, Injectable, OnDestroy, Optional } from '@angular/core';\nimport { actionProxyHandler } from './proxy';\nimport { Subject } from 'rxjs';\n\ntype SubjectMap<T> = { [K in keyof T]: Subject<T[K]> };\n\n/**\n * This class creates RxActions bound to Angular's DI life-cycles. This prevents memory leaks and optionally makes the instance reusable across the app.\n * The main function here is called `create`, optionally you can also call `destroy` to complete all action channels.\n * If the instantiator gets destroyed also the actions get destroyed automatically.\n *\n * @example\n * const factory = new RxActionFactory<{search: string}>();\n * const actions = factory.create();\n * actions.search('');\n * actions.search$.subscribe();\n */\n@Injectable()\nexport class RxActionFactory<T extends Partial<Actions>> implements OnDestroy {\n  private subjects: SubjectMap<T>[] = [] as SubjectMap<T>[];\n\n  constructor(\n    @Optional()\n    private readonly errorHandler?: ErrorHandler\n  ) {}\n\n  /*\n   * Returns a object based off of the provided typing with a separate setter `[prop](value: T[K]): void` and observable stream `[prop]$: Observable<T[K]>`;\n   *\n   * { search: string } => { search$: Observable<string>, search: (value: string) => void;}\n   *\n   * @example\n   *\n   * interface UIActions {\n   *  search: string,\n   *  submit: void\n   * };\n   *\n   * const actions = new RxActionFactory<UIActions>().create();\n   *\n   * actions.search($event.target.value);\n   * actions.search$.subscribe();\n   *\n   * As it is well typed the following things would not work:\n   * actions.submit('not void'); // not void\n   * actions.search(); // requires an argument\n   * actions.search(42); // not a string\n   * actions.search$.error(new Error('traraaa')); // not possible by typings as well as in code\n   * actions.search = \"string\"; // not a setter. the proxy will throw an error pointing out that you have to call it\n   *\n   * @param transforms - A map of transform functions to apply on transformations to actions before emitting them.\n   * This is very useful to clean up bloated templates and components. e.g. `[input]=\"$event?.target?.value\"` => `[input]=\"$event\"`\n   *\n   * @example\n   * function coerceSearchActionParams(e: Event | string | number): string {\n   *   if(e?.target?.value !== undefined) {\n   *      return e?.target?.value + ''\n   *   }\n   *   return e + '';\n   * }\n   * const actions = getActions<search: string, submit: void>({search: coerceSearchActionParams, submit: (v: any) => void 0;});\n   *\n   * actions.search($event);\n   * actions.search('string');\n   * actions.search(42);\n   * actions.submit('not void'); // does not error anymore\n   * actions.search$.subscribe(); // string Observable\n   *\n   */\n  create<U extends ActionTransforms<T> = {}>(transforms?: U): RxActions<T, U> {\n    const subjects: SubjectMap<T> = {} as SubjectMap<T>;\n    this.subjects.push(subjects);\n\n    function signals(): void {}\n    return new Proxy(\n      signals as any as RxActions<T, U>,\n      actionProxyHandler(\n        subjects as any as { [K in keyof T]: Subject<ValuesOf<T>> },\n        transforms,\n        this.errorHandler\n      )\n    ) as any as RxActions<T, U>;\n  }\n\n  destroy() {\n    this.subjects.forEach((s) => {\n      Object.values(s).forEach((subject: any) => subject.complete());\n    })\n  }\n\n  /**\n   * @internal\n   * Internally used to clean up potential subscriptions to the subjects. (For Actions it is most probably a rare case but still important to care about)\n   */\n  ngOnDestroy() {\n    this.destroy();\n  }\n}\n"]}