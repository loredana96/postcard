import { BehaviorSubject, EMPTY, merge, queueScheduler, Subject, } from 'rxjs';
import { catchError, distinctUntilChanged, mergeAll, observeOn, publish, publishReplay, scan, tap, withLatestFrom, } from 'rxjs/operators';
const defaultAccumulator = (st, sl) => {
    return Object.assign(Object.assign({}, st), sl);
};
export function createAccumulationObservable(stateObservables = new Subject(), stateSlices = new Subject(), accumulatorObservable = new BehaviorSubject(defaultAccumulator)) {
    const signal$ = merge(stateObservables.pipe(distinctUntilChanged(), mergeAll(), observeOn(queueScheduler)), stateSlices.pipe(observeOn(queueScheduler))).pipe(withLatestFrom(accumulatorObservable.pipe(observeOn(queueScheduler))), scan((state, [slice, stateAccumulator]) => stateAccumulator(state, slice), {}), tap((newState) => (compositionObservable.state = newState), (error) => console.error(error)), 
    // @Notice We catch the error here as it get lost in between `publish` and `publishReplay`. We return empty to
    catchError((e) => EMPTY), publish());
    const state$ = signal$.pipe(publishReplay(1));
    const compositionObservable = {
        state: {},
        signal$,
        state$,
        nextSlice,
        nextSliceObservable,
        nextAccumulator,
        subscribe,
    };
    // ======
    return compositionObservable;
    // ======
    function nextAccumulator(accumulatorFn) {
        accumulatorObservable.next(accumulatorFn);
    }
    function nextSlice(stateSlice) {
        stateSlices.next(stateSlice);
    }
    function nextSliceObservable(stateObservable) {
        stateObservables.next(stateObservable);
    }
    function subscribe() {
        const sub = compositionObservable.signal$.connect();
        sub.add(compositionObservable.state$.connect());
        sub.add(() => {
            accumulatorObservable.complete();
            stateObservables.complete();
            stateSlices.complete();
        });
        return sub;
    }
}
//# sourceMappingURL=accumulation-observable.js.map