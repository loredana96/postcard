{"version":3,"file":"accumulation-observable.js","sourceRoot":"","sources":["../../../../../../libs/state/selections/src/lib/accumulation-observable.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,eAAe,EAEf,KAAK,EACL,KAAK,EAEL,cAAc,EACd,OAAO,GAER,MAAM,MAAM,CAAC;AACd,OAAO,EACL,UAAU,EACV,oBAAoB,EACpB,QAAQ,EACR,SAAS,EACT,OAAO,EACP,aAAa,EACb,IAAI,EACJ,GAAG,EACH,cAAc,GACf,MAAM,gBAAgB,CAAC;AAGxB,MAAM,kBAAkB,GAAmB,CAAI,EAAK,EAAE,EAAc,EAAK,EAAE;IACzE,uCAAY,EAAE,GAAK,EAAE,EAAG;AAC1B,CAAC,CAAC;AAEF,MAAM,UAAU,4BAA4B,CAC1C,mBAAmB,IAAI,OAAO,EAA0B,EACxD,cAAc,IAAI,OAAO,EAAc,EACvC,qBAAqB,GAAG,IAAI,eAAe,CAAC,kBAAkB,CAAC;IAE/D,MAAM,OAAO,GAAG,KAAK,CACnB,gBAAgB,CAAC,IAAI,CACnB,oBAAoB,EAAE,EACtB,QAAQ,EAAE,EACV,SAAS,CAAC,cAAc,CAAC,CAC1B,EACD,WAAW,CAAC,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC,CAC5C,CAAC,IAAI,CACJ,cAAc,CAAC,qBAAqB,CAAC,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC,CAAC,EACrE,IAAI,CACF,CAAC,KAAK,EAAE,CAAC,KAAK,EAAE,gBAAgB,CAAC,EAAE,EAAE,CAAC,gBAAgB,CAAC,KAAK,EAAE,KAAK,CAAC,EACpE,EAAO,CACR,EACD,GAAG,CACD,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,qBAAqB,CAAC,KAAK,GAAG,QAAQ,CAAC,EACtD,CAAC,KAAK,EAAE,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAChC;IACD,8GAA8G;IAC9G,UAAU,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,KAAK,CAAC,EACxB,OAAO,EAAE,CACV,CAAC;IACF,MAAM,MAAM,GAAkB,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;IAC7D,MAAM,qBAAqB,GAAmB;QAC5C,KAAK,EAAE,EAAO;QACd,OAAO;QACP,MAAM;QACN,SAAS;QACT,mBAAmB;QACnB,eAAe;QACf,SAAS;KACV,CAAC;IAEF,SAAS;IAET,OAAO,qBAAqB,CAAC;IAE7B,SAAS;IAET,SAAS,eAAe,CAAC,aAA6B;QACpD,qBAAqB,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;IAC5C,CAAC;IAED,SAAS,SAAS,CAAC,UAAsB;QACvC,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IAC/B,CAAC;IAED,SAAS,mBAAmB,CAAC,eAAuC;QAClE,gBAAgB,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;IACzC,CAAC;IAED,SAAS,SAAS;QAChB,MAAM,GAAG,GACP,qBAAqB,CAAC,OACvB,CAAC,OAAO,EAAE,CAAC;QACZ,GAAG,CAAC,GAAG,CACJ,qBAAqB,CAAC,MAAmC,CAAC,OAAO,EAAE,CACrE,CAAC;QACF,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE;YACX,qBAAqB,CAAC,QAAQ,EAAE,CAAC;YACjC,gBAAgB,CAAC,QAAQ,EAAE,CAAC;YAC5B,WAAW,CAAC,QAAQ,EAAE,CAAC;QACzB,CAAC,CAAC,CAAC;QACH,OAAO,GAAG,CAAC;IACb,CAAC;AACH,CAAC","sourcesContent":["import {\n  BehaviorSubject,\n  ConnectableObservable,\n  EMPTY,\n  merge,\n  Observable,\n  queueScheduler,\n  Subject,\n  Subscription,\n} from 'rxjs';\nimport {\n  catchError,\n  distinctUntilChanged,\n  mergeAll,\n  observeOn,\n  publish,\n  publishReplay,\n  scan,\n  tap,\n  withLatestFrom,\n} from 'rxjs/operators';\nimport { AccumulationFn, Accumulator } from './model';\n\nconst defaultAccumulator: AccumulationFn = <T>(st: T, sl: Partial<T>): T => {\n  return { ...st, ...sl };\n};\n\nexport function createAccumulationObservable<T extends object>(\n  stateObservables = new Subject<Observable<Partial<T>>>(),\n  stateSlices = new Subject<Partial<T>>(),\n  accumulatorObservable = new BehaviorSubject(defaultAccumulator)\n): Accumulator<T> {\n  const signal$ = merge(\n    stateObservables.pipe(\n      distinctUntilChanged(),\n      mergeAll(),\n      observeOn(queueScheduler)\n    ),\n    stateSlices.pipe(observeOn(queueScheduler))\n  ).pipe(\n    withLatestFrom(accumulatorObservable.pipe(observeOn(queueScheduler))),\n    scan(\n      (state, [slice, stateAccumulator]) => stateAccumulator(state, slice),\n      {} as T\n    ),\n    tap(\n      (newState) => (compositionObservable.state = newState),\n      (error) => console.error(error)\n    ),\n    // @Notice We catch the error here as it get lost in between `publish` and `publishReplay`. We return empty to\n    catchError((e) => EMPTY),\n    publish()\n  );\n  const state$: Observable<T> = signal$.pipe(publishReplay(1));\n  const compositionObservable: Accumulator<T> = {\n    state: {} as T,\n    signal$,\n    state$,\n    nextSlice,\n    nextSliceObservable,\n    nextAccumulator,\n    subscribe,\n  };\n\n  // ======\n\n  return compositionObservable;\n\n  // ======\n\n  function nextAccumulator(accumulatorFn: AccumulationFn): void {\n    accumulatorObservable.next(accumulatorFn);\n  }\n\n  function nextSlice(stateSlice: Partial<T>): void {\n    stateSlices.next(stateSlice);\n  }\n\n  function nextSliceObservable(stateObservable: Observable<Partial<T>>): void {\n    stateObservables.next(stateObservable);\n  }\n\n  function subscribe(): Subscription {\n    const sub = (\n      compositionObservable.signal$ as ConnectableObservable<T>\n    ).connect();\n    sub.add(\n      (compositionObservable.state$ as ConnectableObservable<T>).connect()\n    );\n    sub.add(() => {\n      accumulatorObservable.complete();\n      stateObservables.complete();\n      stateSlices.complete();\n    });\n    return sub;\n  }\n}\n"]}