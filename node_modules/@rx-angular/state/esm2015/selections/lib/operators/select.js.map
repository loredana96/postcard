{"version":3,"file":"select.js","sourceRoot":"","sources":["../../../../../../../libs/state/selections/src/lib/operators/select.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,GAAG,EAAE,KAAK,EAAE,MAAM,gBAAgB,CAAC;AAE5C,OAAO,EACL,qBAAqB,EACrB,6BAA6B,EAC7B,gDAAgD,EAChD,kBAAkB,GACnB,MAAM,iBAAiB,CAAC;AACzB,OAAO,EAAE,aAAa,EAAE,MAAM,0BAA0B,CAAC;AACzD,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AA8LtC;;GAEG;AACH,MAAM,UAAU,MAAM,CACpB,GAAG,SAQE;IAEL,OAAO,CAAC,MAAqB,EAAE,EAAE;QAC/B,IAAI,CAAC,SAAS,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;YACxC,OAAO,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;SAChC;aAAM,IAAI,6BAA6B,CAAC,SAAS,CAAC,EAAE;YACnD,OAAO,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;SACzE;aAAM,IAAI,gDAAgD,CAAC,SAAS,CAAC,EAAE;YACtE,OAAO,MAAM,CAAC,IAAI,CAChB,WAAW,CACT,SAAS,CAAC,CAAC,CAAgB,EAC3B,SAAS,CAAC,CAAC,CAAC,CACb,EACD,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAC5B,CAAC;SACH;aAAM,IAAI,kBAAkB,CAAC,SAAS,CAAC,EAAE;YACxC,OAAO,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;SACnD;aAAM,IAAI,qBAAqB,CAAC,SAAS,CAAC,EAAE;YAC3C,OAAO,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;SACxD;aAAM;YACL,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;SAClD;IACH,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import { MonoTypeOperatorFunction, Observable, OperatorFunction } from 'rxjs';\nimport { map, pluck } from 'rxjs/operators';\nimport { KeyCompareMap, PickSlice } from '../interfaces';\nimport {\n  isOperateFnArrayGuard,\n  isStringAndFunctionTupleGuard,\n  isStringArrayFunctionAndOptionalObjectTupleGuard,\n  isStringArrayGuard,\n} from '../utils/guards';\nimport { pipeFromArray } from '../utils/pipe-from-array';\nimport { selectSlice } from './selectSlice';\nimport { stateful } from './stateful';\n\n/**\n * @description\n * Returns the state as shared, replayed and distinct `Observable<T>`. This way you don't have to think about late\n * subscribers, multiple subscribers or multiple emissions of the same value.\n *\n * @example\n * const state$ = state.pipe(select());\n * state$.subscribe(state => doStuff(state));\n *\n * @returns Observable<T>\n */\n\nexport function select<T>(): MonoTypeOperatorFunction<T>;\n\n/**\n * @description\n * Returns the state as cached and distinct `Observable<A>`. Accepts arbitrary\n * [rxjs operators](https://rxjs-dev.firebaseapp.com/guide/operators) to enrich the selection with reactive composition.\n *\n * @example\n * const profilePicture$ = state.pipe(\n *   select(\n *    pluck('profilePicture'),\n *    switchMap(profilePicture => mapImageAsync(profilePicture))\n *   )\n * );\n * @param  { OperatorFunction<T, A> } op\n * @returns Observable<A>\n *\n * @docsPage select\n * @docsCategory operators\n */\nexport function select<T, A>(\n  op: OperatorFunction<T, A>\n): OperatorFunction<T, A>;\n/**\n * @internal\n */\nexport function select<T, A, B>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>\n): OperatorFunction<T, B>;\n/**\n * @internal\n */\nexport function select<T, A, B, C>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>\n): OperatorFunction<T, C>;\n/**\n * @internal\n */\nexport function select<T, A, B, C, D>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>\n): OperatorFunction<T, D>;\n/**\n * @internal\n */\nexport function select<T, A, B, C, D, E>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>,\n  op5: OperatorFunction<D, E>\n): OperatorFunction<T, E>;\n\n/**\n * @description\n * Transform a slice of the state by providing keys and map function.\n * Returns result of applying function to state slice as cached and distinct `Observable<R>`.\n *\n * @example\n * // Project state slice\n * const text$ = state$.pipe(\n *   select(\n *     ['query', 'results'],\n *     ({ query, results }) => `${results.length} results found for \"${query}\"`\n *   )\n * );\n *\n * @return Observable<R>\n */\nexport function select<T extends object, K extends keyof T, R>(\n  keys: K[],\n  fn: (slice: PickSlice<T, K>) => R,\n  keyCompareMap?: KeyCompareMap<Pick<T, K>>\n): OperatorFunction<T, R>;\n\n/**\n * @description\n * Transform a single property of the state by providing a key and map function.\n * Returns result of applying function to state property as cached and distinct `Observable<T[R]>`.\n *\n * @example\n * // Project state based on single property\n * const foo$ = state$.pipe(select('bar', bar => `bar equals ${bar}`));\n *\n * @return Observable<R>\n */\nexport function select<T, K extends keyof T, R>(\n  k: K,\n  fn: (val: T[K]) => R\n): OperatorFunction<T, R>;\n\n/**\n * @description\n * Access a single property of the state by providing keys.\n * Returns a single property of the state as cached and distinct `Observable<T[K1]>`.\n *\n * @example\n * // Access a single property\n * const bar$ = state$.pipe(select('bar'));\n *\n * // Access a nested property\n * const foo$ = state$.pipe(select('bar', 'foo'));\n *\n * @return Observable<T[K1]>\n */\nexport function select<T, K1 extends keyof T>(\n  k1: K1\n): OperatorFunction<T, T[K1]>;\n/**\n * @internal\n */\nexport function select<T, K1 extends keyof T, K2 extends keyof T[K1]>(\n  k1: K1,\n  k2: K2\n): OperatorFunction<T, T[K1][K2]>;\n/**\n * @internal\n */\nexport function select<\n  T,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2]\n>(k1: K1, k2: K2, k3: K3): OperatorFunction<T, T[K1][K2][K3]>;\n/**\n * @internal\n */\nexport function select<\n  T,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3]\n>(k1: K1, k2: K2, k3: K3, k4: K4): OperatorFunction<T, T[K1][K2][K3][K4]>;\n/**\n * @internal\n */\nexport function select<\n  T,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n  K5 extends keyof T[K1][K2][K3][K4]\n>(\n  k1: K1,\n  k2: K2,\n  k3: K3,\n  k4: K4,\n  k5: K5\n): OperatorFunction<T, T[K1][K2][K3][K4][K5]>;\n/**\n * @internal\n */\nexport function select<\n  T,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n  K5 extends keyof T[K1][K2][K3][K4],\n  K6 extends keyof T[K1][K2][K3][K4][K5]\n>(\n  k1: K1,\n  k2: K2,\n  k3: K3,\n  k4: K4,\n  k5: K5,\n  k6: K6\n): OperatorFunction<T, T[K1][K2][K3][K4][K5][K6]>;\n\n/**\n * @internal\n */\nexport function select<T extends Record<string, unknown>>(\n  ...opOrMapFn:\n    | OperatorFunction<T, unknown>[]\n    | string[]\n    | [k: string, fn: (val: unknown) => unknown]\n    | [\n        keys: string[],\n        fn: (slice: unknown) => unknown,\n        keyCompareMap?: KeyCompareMap<T>\n      ]\n): OperatorFunction<T, unknown> {\n  return (state$: Observable<T>) => {\n    if (!opOrMapFn || opOrMapFn.length === 0) {\n      return state$.pipe(stateful());\n    } else if (isStringAndFunctionTupleGuard(opOrMapFn)) {\n      return state$.pipe(stateful(map((s) => opOrMapFn[1](s[opOrMapFn[0]]))));\n    } else if (isStringArrayFunctionAndOptionalObjectTupleGuard(opOrMapFn)) {\n      return state$.pipe(\n        selectSlice<T & object, keyof T>(\n          opOrMapFn[0] as (keyof T)[],\n          opOrMapFn[2]\n        ),\n        stateful(map(opOrMapFn[1]))\n      );\n    } else if (isStringArrayGuard(opOrMapFn)) {\n      return state$.pipe(stateful(pluck(...opOrMapFn)));\n    } else if (isOperateFnArrayGuard(opOrMapFn)) {\n      return state$.pipe(stateful(pipeFromArray(opOrMapFn)));\n    } else {\n      throw new Error('wrong params passed to select');\n    }\n  };\n}\n"]}