{"version":3,"file":"selectSlice.js","sourceRoot":"","sources":["../../../../../../../libs/state/selections/src/lib/operators/selectSlice.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,gBAAgB,CAAC;AAE7C,OAAO,EAAE,wBAAwB,EAAE,MAAM,4BAA4B,CAAC;AAEtE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAwEG;AACH,MAAM,UAAU,WAAW,CACzB,IAAS,EACT,aAAiD;IAEjD,OAAO,CAAC,EAAiB,EAA+B,EAAE,CACxD,EAAE,CAAC,IAAI,CACL,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,KAAK,SAAS,CAAC,EACtC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;QACZ,eAAe;QACf,IAAI,KAAK,KAAK,IAAI,EAAE;YAClB,OAAO,IAAI,CAAC;SACb;QACD,yEAAyE;QACzE,MAAM,WAAW,GAAG,IAAI;YACtB,+DAA+D;aAC9D,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC,CAAC;QAEpE,oDAAoD;QACpD,uEAAuE;QAEvE,4CAA4C;QAC5C,kDAAkD;QAClD,8DAA8D;QAC9D,gEAAgE;QAChE,4EAA4E;QAC5E,wEAAwE;QACxE,sFAAsF;QACtF,IAAI,WAAW,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE;YACpC,OAAO,SAAS,CAAC;SAClB;QAED,4BAA4B;QAC5B,OAAO,WAAW;aACf,MAAM,CAAC,CAAC,EAAE,EAAE,GAAG,EAAE,EAAE;YAClB,EAAE,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC;YACrB,OAAO,EAAE,CAAC;QACZ,CAAC,EAAE,EAAqB,CAAC,CAAC;IAC9B,CAAC,CAAC,EACF,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,SAAS,CAAC,EAC9B,wBAAwB,CAAC,IAAI,EAAE,aAAa,CAAC,CAC9C,CAAC;AACN,CAAC","sourcesContent":["import { Observable, OperatorFunction } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\nimport { KeyCompareMap, PickSlice } from '../interfaces/index';\nimport { distinctUntilSomeChanged } from './distinctUntilSomeChanged';\n\n/**\n * @description\n *\n * Returns an Observable that emits only the provided `keys` emitted by the source Observable. Each key will get\n * filtered to only emit _defined_ values as well as checked for distinct emissions.\n * Comparison will be done for each set key in the `keys` array.\n *\n * `selectSlice` will only emit _valid_ selections. A selection is _valid_ if every\n * selected key exists and is defined in the source Observable. This ensures that the `selectSlice`\n * operator will always return a complete slice with all values defined.\n *\n * You can fine grain your distinct checks by providing a `KeyCompareMap` with those keys you want to compute\n * explicitly different\n *\n * @example\n *\n * // An example with a custom comparison applied to each key\n * import { of } from 'rxjs';\n * import { selectSlice } from 'rx-angular/state';\n *\n *\n * const state$: Observable<MyState> = of(\n *  { title: 'myTitle', panelOpen: true},\n *  { title: 'myTitle2', panelOpen: true},\n *  { title: 'newTitle', panelOpen: true},\n *  { title: 'newTitle', panelOpen: false}\n * )\n * .pipe(\n *     selectSlice(['title', 'panelOpen']),\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // displays:\n * //  { title: 'myTitle', panelOpen: true },\n * //  { title: 'myTitle2', panelOpen: true },\n * //  { title: 'newTitle', panelOpen: true },\n * //  { title: 'newTitle', panelOpen: false }\n *\n * @example\n *\n * import { of, Observable } from 'rxjs';\n * import { tap } from 'rxjs/operators';\n * import { selectSlice } from 'rx-angular/state';\n *\n * interface MyState {\n *    title: string;\n *    items: string[];\n *    panelOpen: boolean;\n * }\n * // Select items and title.\n * // apply custom compare logic for the items array\n * const customComparison: KeyCompareMap<MyState> = {\n *   items: (oldItems, newItems) => compareItems(oldItems, newItems)\n * };\n * const state$: Observable<MyState> = of(\n * { title: 'myTitle', items: ['foo', 'bar'], panelOpen: true },\n * { title: 'myTitle', items: ['foo', 'bar'], panelOpen: false },\n * { title: 'nextTitle', items: ['foo', 'baR'], panelOpen: true },\n * { title: 'nextTitle', items: ['fooRz', 'boo'], panelOpen: false },\n * );\n * const slice$ = state$.pipe(selectSlice(['title', 'items'], customComparison), tap(console.log)).subscribe();\n *\n * // displays:\n * // { title: 'myTitle', items: ['foo', 'bar'] }\n * // { title: 'nextTitle', items: ['foo', 'baR'] }\n * // { title: 'nextTitle', items: ['fooRz', 'boo'] }\n *\n * @param {(K)[]} keys - the array of keys which should be selected\n * @param {KeyCompareMap<{ [P in K]: T[P] }>} [keyCompareMap] Optional KeyCompareMap to provide custom compare logic\n * for some the keys\n * @docsPage selectSlice\n * @docsCategory operators\n */\nexport function selectSlice<T extends object, K extends keyof T>(\n  keys: K[],\n  keyCompareMap?: KeyCompareMap<{ [P in K]: T[P] }>\n): OperatorFunction<T, PickSlice<T, K>> {\n  return (o$: Observable<T>): Observable<PickSlice<T, K>> =>\n    o$.pipe(\n      filter((state) => state !== undefined),\n      map((state) => {\n        // forward null\n        if (state === null) {\n          return null;\n        }\n        // an array of all keys which exist and are _defined_ in the state object\n        const definedKeys = keys\n          // filter out undefined properties e. g. {}, { str: undefined }\n          .filter((k) => state.hasOwnProperty(k) && state[k] !== undefined);\n\n        // we want to ensure to only emit _valid_ selections\n        // a selection is _valid_ if every selected key exists and has a value:\n\n        // {} => selectSlice(['foo']) => no emission\n        // {str: 'test'} => selectSlice([]) => no emission\n        // {str: 'test'} => selectSlice(['notPresent']) => no emission\n        // {str: 'test'} => state.select(selectSlice([])) => no emission\n        // {str: 'test'} => state.select(selectSlice(['notPresent'])) => no emission\n        // {str: undefined} => state.select(selectSlice(['str'])) => no emission\n        // {str: 'test', foo: undefined } => state.select(selectSlice(['foo'])) => no emission\n        if (definedKeys.length < keys.length) {\n          return undefined;\n        }\n\n        // create the selected slice\n        return definedKeys\n          .reduce((vm, key) => {\n            vm[key] = state[key];\n            return vm;\n          }, {} as PickSlice<T, K>);\n      }),\n      filter((v) => v !== undefined),\n      distinctUntilSomeChanged(keys, keyCompareMap)\n    );\n}\n\n"]}