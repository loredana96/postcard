{"version":3,"file":"stateful.js","sourceRoot":"","sources":["../../../../../../../libs/state/selections/src/lib/operators/stateful.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,oBAAoB,EAAE,MAAM,EAAE,WAAW,EAAE,MAAM,gBAAgB,CAAC;AAE3E,OAAO,EAAE,qBAAqB,EAAE,MAAM,iBAAiB,CAAC;AACxD,OAAO,EAAE,aAAa,EAAE,MAAM,0BAA0B,CAAC;AAoFzD;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACH,MAAM,UAAU,QAAQ,CACtB,GAAG,cAAwC;IAE3C,OAAO,CAAC,CAAgB,EAAiD,EAAE;QACzE,OAAO,CAAC,CAAC,IAAI;QACX,gHAAgH;QAChH,gDAAgD;QAChD,oBAAoB,EAAE;QACtB,oBAAoB;QACpB,CAAC,CAAgB,EAAqB,EAAE;YACtC,IAAI,qBAAqB,CAAC,cAAc,CAAC,EAAE;gBACzC,OAAO,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,CAAC,CAAC;aAC9C;YACD,OAAO,CAAC,CAAC;QACX,CAAC;QACD,wEAAwE;QACxE,MAAM,CAAC,CAAC,CAAC,EAA+B,EAAE,CAAC,CAAC,KAAK,SAAS,CAAC;QAC3D,iCAAiC;QACjC,oBAAoB,EAAE;QACtB,gGAAgG;QAChG,WAAW,CAAC,EAAE,UAAU,EAAE,CAAC,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC,CAC/C,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import { Observable, OperatorFunction } from 'rxjs';\nimport { distinctUntilChanged, filter, shareReplay } from 'rxjs/operators';\nimport { NonUndefined } from '../interfaces';\nimport { isOperateFnArrayGuard } from '../utils/guards';\nimport { pipeFromArray } from '../utils/pipe-from-array';\n\n/**\n * @description\n *\n * As the name `stateful` implies this operator is useful when you process an Observable which maintains state.\n *\n * Maintaining state as an `Observable` source comes with a handful of repetitive as well as use case specific tasks.\n *\n * It acts like the Observables `pipe` method.\n * It accepts RxJS operators and composes them like `Observable#pipe` and the standalone `pipe` method.\n *\n * Furthermore, it takes care of the above mentioned repetitive tasks as listed below.\n *\n * You will always (aka repetitive) want to ensure that:\n * - only distinct state changes are emitted\n * - only defined values are emitted (filter out undefined, which ensures lazy state)\n * - share and replay custom operations for multiple subscribers (saves performance)\n *\n * You will sometimes (aka situational) need:\n * - a subset of the state (derivations)\n * - compose the state with other Observables or change the Observables behaviour\n *\n *\n * @example\n * import { Observable } from 'rxjs';\n * import { map } from 'rxjs/operators';\n * import { stateful } from 'rx-angular/state';\n *\n * const state$: Observable<{ name: string; items: string[] }>;\n * const derivation$ = state$.pipe(\n *   stateful(\n *     map(state => state.list.length),\n *     filter(length => length > 3)\n *   )\n * );\n *\n * @param {OperatorFunction<T, A>} op - one or multiple passed operator comma separated\n * @return OperatorFunction<T, NonUndefined<A>>\n *\n * @docsPage stateful\n * @docsCategory operators\n */\nexport function stateful<T>(): OperatorFunction<T, NonUndefined<T>>;\n/**\n * @internal\n */\nexport function stateful<T, A>(\n  op: OperatorFunction<T, A>\n): OperatorFunction<T, NonUndefined<A>>;\n/**\n * @internal\n */\nexport function stateful<T, A, B>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>\n): OperatorFunction<T, NonUndefined<B>>;\n/**\n * @internal\n */\nexport function stateful<T, A, B, C>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>\n): OperatorFunction<T, NonUndefined<C>>;\n/**\n * @internal\n */\nexport function stateful<T, A, B, C, D>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>\n): OperatorFunction<T, NonUndefined<D>>;\n/**\n * @internal\n */\nexport function stateful<T, A, B, C, D, E>(\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>,\n  op5: OperatorFunction<D, E>\n): OperatorFunction<T, NonUndefined<E>>;\n/**\n * @description\n *\n * As it acts like the Observables `pipe` method, it accepts one or many RxJS operators as params.\n *\n * @example\n * import { Observable } from 'rxjs';\n * import { map } from 'rxjs/operators';\n * import { stateful } from 'rx-angular/state';\n *\n * const state$: Observable<{ name: string; items: string[] }>;\n * const derivation$ = state$.pipe(\n *   stateful(\n *     map(state => state.list.length),\n *     filter(length => length > 3)\n *   )\n * );\n *\n * @param {OperatorFunction<T, A>} op - one or multiple passed operator comma separated\n *\n * @docsPage stateful\n * @docsCategory operators\n */\nexport function stateful<T, R>(\n  ...optionalDerive: OperatorFunction<T, R>[]\n): OperatorFunction<T, NonUndefined<T> | NonUndefined<R>> {\n  return (s: Observable<T>): Observable<NonUndefined<T> | NonUndefined<R>> => {\n    return s.pipe(\n      // distinct same base-state objects (e.g. a default emission of default switch cases, incorrect mutable handling\n      // of data) @TODO evaluate benefits vs. overhead\n      distinctUntilChanged(),\n      // CUSTOM LOGIC HERE\n      (o: Observable<T>): Observable<T | R> => {\n        if (isOperateFnArrayGuard(optionalDerive)) {\n          return o.pipe(pipeFromArray(optionalDerive));\n        }\n        return o;\n      },\n      // initial emissions, undefined is no base-state, pollution with skip(1)\n      filter((v): v is NonUndefined<typeof v> => v !== undefined),\n      // distinct same derivation value\n      distinctUntilChanged(),\n      // reuse custom operations result for multiple subscribers and reemit the last calculated value.\n      shareReplay({ bufferSize: 1, refCount: true })\n    );\n  };\n}\n"]}