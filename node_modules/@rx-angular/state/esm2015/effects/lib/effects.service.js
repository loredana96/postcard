import { ErrorHandler, Injectable, Optional } from '@angular/core';
import { EMPTY, from, pipe, Subject, Subscription } from 'rxjs';
import { catchError, filter, mapTo, mergeAll, share, takeUntil, tap } from 'rxjs/operators';
import { toHook, untilDestroyed } from './utils';
import * as i0 from "@angular/core";
/**
 * Reduces subscription boilerplate for performing observable-based side-effects in components.
 *
 * Before:
 * ```ts
 * @Component({
 *   // ...
 * })
 * export class FooComponent implements OnDestroy {
 *   private readonly destroy$ = new Subject<void>();
 *
 *   constructor() {
 *     obs$.pipe(takeUntil(this.destroy$)).subscribe(doSideEffect);
 *   }
 *
 *   ngOnDestroy(): void {
 *     this.destroy$.next();
 *     this.destroy$.complete();
 *   }
 * }
 * ```
 *
 * After:
 * ```ts
 * @Component({
 *   // ...
 *   providers: [RxEffects],
 * })
 * export class FooComponent {
 *   constructor(effects: RxEffects) {
 *     effects.register(obs$, doSideEffect);
 *     // OR
 *     effects.register(obs$.pipe(tap(doSideEffect)));
 *     // OR
 *     effects.register(obs$.subscribe(doSideEffect));
 *   }
 * }
 * ```
 *
 * NOTE: Avoid calling register/unregister/subscribe inside the side-effect function.
 */
export class RxEffects {
    constructor(errorHandler) {
        this.errorHandler = errorHandler;
        this._hooks$ = new Subject();
        this.observables$ = new Subject();
        // we have to use publish here to make it hot (composition happens without subscriber)
        this.effects$ = this.observables$.pipe(mergeAll(), share());
        this.subscription = this.effects$.subscribe();
        this.onDestroy$ = this._hooks$.pipe(toHook('destroy'));
        this.destroyers = {};
    }
    register(obsOrSub, fnOrObj) {
        if (obsOrSub instanceof Subscription) {
            this.subscription.add(obsOrSub);
            return;
        }
        const effectId = RxEffects.nextId++;
        const destroy$ = (this.destroyers[effectId] = new Subject());
        const applyBehavior = pipe(mapTo(effectId), takeUntil(destroy$));
        if (fnOrObj != null) {
            this.observables$.next(from(obsOrSub).pipe(
            // ternary expression is to help Typescript infer overloads
            typeof fnOrObj === 'function' ? tap(fnOrObj) : tap(fnOrObj), catchError((err) => {
                var _a;
                (_a = this.errorHandler) === null || _a === void 0 ? void 0 : _a.handleError(err);
                return EMPTY;
            }), applyBehavior));
        }
        else {
            this.observables$.next(from(obsOrSub).pipe(applyBehavior));
        }
        return effectId;
    }
    /**
     * Imperatively cancel a side-effect while the component is still running.
     *
     * Note that all effects are automatically cancelled when a component is destroyed,
     * so you most often won't need to call this method.
     * @param effectId Effect ID (returned by register method)
     */
    unregister(effectId) {
        var _a;
        (_a = this.destroyers[effectId]) === null || _a === void 0 ? void 0 : _a.next();
    }
    /**
     * Fires a sideEffect when the instances `OnDestroy` hook is fired.
     *
     * @example
     * effects.registerOnDestroy(mode => localStorage.setItem('colorMode', mode));
     *
     * @param sideEffect
     */
    registerOnDestroy(sideEffect) {
        return this.register(this.onDestroy$, sideEffect);
    }
    /**
     * Operator that unsubscribes based on emission of an registered effect.
     *
     * @NOTICE
     * This operator has to be placed always at the end of the operator chain (before the subscription).
     * Otherwise we may leak as a subsequent operator could instantiate new ongoing Observables which will not get unsubscribed.
     *
     * @example
     * const effectId1 = effects.register(
     *   colorMode$.subscribe(mode => localStorage.setItem('colorMode', mode))
     * );
     *
     * someValue$.pipe(
     *    effect.untilEffect(effectId1)
     * )
     *
     */
    untilEffect(effectId) {
        return (source) => source.pipe(untilDestroyed(this), takeUntil(this.effects$.pipe(filter((eId) => eId === effectId))));
    }
    /**
     * @internal
     */
    ngOnDestroy() {
        this._hooks$.next({ destroy: true });
        this.subscription.unsubscribe();
    }
}
RxEffects.nextId = 0;
/** @nocollapse */ RxEffects.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: RxEffects, deps: [{ token: i0.ErrorHandler, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ RxEffects.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: RxEffects });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: RxEffects, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.ErrorHandler, decorators: [{
                    type: Optional
                }] }]; } });
//# sourceMappingURL=effects.service.js.map