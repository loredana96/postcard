{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../../../../libs/state/effects/src/lib/utils.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,MAAM,EAAE,KAAK,EAAE,WAAW,EAAE,IAAI,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAC;AAG7E,MAAM,UAAU,yBAAyB,CACvC,IAAa;IAEb,OAAO,CAAC,CAAC,IAAI,IAAI,OAAO,IAAI,KAAK,QAAQ,IAAI,IAAI,KAAK,EAAE,CAAC;AAC3D,CAAC;AAED;;;GAGG;AACH,MAAM,mBAAmB,GAAG,CAAC,EAAoB,EAAoB,EAAE,CACrE,EAAE,CAAC,IAAI,CACL,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,EACzB,IAAI,CAAC,CAAC,CAAC,EACP,WAAW,EAAE,CACd,CAAC;AAEJ;;;;;GAKG;AACH,MAAM,UAAU,MAAM,CAA4B,IAAO;IACvD,MAAM,SAAS,GAAG,yBAAyB,CAAC,IAAI,CAAC;QAC/C,CAAC,CAAC,mBAAmB;QACrB,CAAC,CAAC,CAAC,CAA2B,EAAoB,EAAE,CAAC,CAAC,CAAC;IACzD,OAAO,CAAC,EAAyB,EAA4B,EAAE,CAC7D,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,SAAS,CAAC,CAAC;AACpC,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,cAAc,CAC5B,qBAAiC;IAEjC,OAAO,CAAC,MAAM,EAAE,EAAE,CAChB,MAAM,CAAC,IAAI,CAAC,SAAS,CAAI,qBAAqB,CAAC,UAAU,CAAC,CAAC,CAAC;AAChE,CAAC","sourcesContent":["import { MonoTypeOperatorFunction, Observable } from 'rxjs';\nimport { filter, pluck, shareReplay, take, takeUntil } from 'rxjs/operators';\nimport { HookProps, OnDestroy$, SingleShotProps } from './model';\n\nexport function isSingleShotHookNameGuard<T>(\n  name: unknown\n): name is keyof SingleShotProps {\n  return !!name && typeof name === 'string' && name !== '';\n}\n\n/**\n * @internal\n * Operator to filter values for single shot observables\n */\nconst singleShotOperators = (o$: Observable<true>): Observable<true> =>\n  o$.pipe(\n    filter((v) => v === true),\n    take(1),\n    shareReplay()\n  );\n\n/**\n * This is an operator that is used to listen to Angular lifecycle hooks.\n * It plucks a defined lefe cycle name `HookProps` and forwards values for the particular value and in the behavior of the hook e.g. single shot\n *\n * @param name\n */\nexport function toHook<H extends keyof HookProps>(name: H) {\n  const operators = isSingleShotHookNameGuard(name)\n    ? singleShotOperators\n    : (o: Observable<HookProps[H]>): Observable<true> => o;\n  return (o$: Observable<HookProps>): Observable<HookProps[H]> =>\n    o$.pipe(pluck(name), operators);\n}\n\n/**\n * This operator can be used to take instances that implements `OnDestroy$` and unsubscribes from the given Observable when the instances\n * `onDestroy$` Observable emits.\n *\n * @param instanceWithLifecycle\n */\nexport function untilDestroyed<V>(\n  instanceWithLifecycle: OnDestroy$\n): MonoTypeOperatorFunction<V> {\n  return (source) =>\n    source.pipe(takeUntil<V>(instanceWithLifecycle.onDestroy$));\n}\n"]}