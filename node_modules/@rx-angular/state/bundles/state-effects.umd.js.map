{"version":3,"file":"state-effects.umd.js","sources":["../../../../libs/state/effects/src/lib/utils.ts","../../../../libs/state/effects/src/lib/effects.service.ts","../../../../libs/state/effects/src/state-effects.ts"],"sourcesContent":["import { MonoTypeOperatorFunction, Observable } from 'rxjs';\nimport { filter, pluck, shareReplay, take, takeUntil } from 'rxjs/operators';\nimport { HookProps, OnDestroy$, SingleShotProps } from './model';\n\nexport function isSingleShotHookNameGuard<T>(\n  name: unknown\n): name is keyof SingleShotProps {\n  return !!name && typeof name === 'string' && name !== '';\n}\n\n/**\n * @internal\n * Operator to filter values for single shot observables\n */\nconst singleShotOperators = (o$: Observable<true>): Observable<true> =>\n  o$.pipe(\n    filter((v) => v === true),\n    take(1),\n    shareReplay()\n  );\n\n/**\n * This is an operator that is used to listen to Angular lifecycle hooks.\n * It plucks a defined lefe cycle name `HookProps` and forwards values for the particular value and in the behavior of the hook e.g. single shot\n *\n * @param name\n */\nexport function toHook<H extends keyof HookProps>(name: H) {\n  const operators = isSingleShotHookNameGuard(name)\n    ? singleShotOperators\n    : (o: Observable<HookProps[H]>): Observable<true> => o;\n  return (o$: Observable<HookProps>): Observable<HookProps[H]> =>\n    o$.pipe(pluck(name), operators);\n}\n\n/**\n * This operator can be used to take instances that implements `OnDestroy$` and unsubscribes from the given Observable when the instances\n * `onDestroy$` Observable emits.\n *\n * @param instanceWithLifecycle\n */\nexport function untilDestroyed<V>(\n  instanceWithLifecycle: OnDestroy$\n): MonoTypeOperatorFunction<V> {\n  return (source) =>\n    source.pipe(takeUntil<V>(instanceWithLifecycle.onDestroy$));\n}\n","import { ErrorHandler, Injectable, OnDestroy, Optional } from '@angular/core';\nimport {\n  EMPTY,\n  from,\n  Observable,\n  ObservableInput,\n  PartialObserver,\n  pipe,\n  Subject,\n  Subscription\n} from 'rxjs';\nimport {\n  catchError,\n  filter,\n  mapTo,\n  mergeAll,\n  share,\n  takeUntil,\n  tap\n} from 'rxjs/operators';\nimport { DestroyProp, OnDestroy$ } from './model';\nimport { toHook, untilDestroyed } from './utils';\n\n/**\n * Reduces subscription boilerplate for performing observable-based side-effects in components.\n *\n * Before:\n * ```ts\n * @Component({\n *   // ...\n * })\n * export class FooComponent implements OnDestroy {\n *   private readonly destroy$ = new Subject<void>();\n *\n *   constructor() {\n *     obs$.pipe(takeUntil(this.destroy$)).subscribe(doSideEffect);\n *   }\n *\n *   ngOnDestroy(): void {\n *     this.destroy$.next();\n *     this.destroy$.complete();\n *   }\n * }\n * ```\n *\n * After:\n * ```ts\n * @Component({\n *   // ...\n *   providers: [RxEffects],\n * })\n * export class FooComponent {\n *   constructor(effects: RxEffects) {\n *     effects.register(obs$, doSideEffect);\n *     // OR\n *     effects.register(obs$.pipe(tap(doSideEffect)));\n *     // OR\n *     effects.register(obs$.subscribe(doSideEffect));\n *   }\n * }\n * ```\n *\n * NOTE: Avoid calling register/unregister/subscribe inside the side-effect function.\n */\n@Injectable()\nexport class RxEffects implements OnDestroy, OnDestroy$ {\n  constructor(\n    @Optional()\n    private readonly errorHandler: ErrorHandler\n  ) {}\n\n  private static nextId = 0;\n  readonly _hooks$ = new Subject<DestroyProp>();\n  private readonly observables$ = new Subject<Observable<unknown>>();\n  // we have to use publish here to make it hot (composition happens without subscriber)\n  private readonly effects$ = this.observables$.pipe(mergeAll(), share());\n  private readonly subscription = this.effects$.subscribe();\n  onDestroy$: Observable<boolean> = this._hooks$.pipe(toHook('destroy'));\n  private readonly destroyers: Record<number, Subject<void>> = {};\n\n  /**\n   * Performs a side-effect whenever a source observable emits, and handles its subscription.\n   *\n   * @example\n   * effects.register(\n   *   colorMode$,\n   *   mode => localStorage.setItem('colorMode', mode)\n   * );\n   *\n   * @param sourceObs Source observable input\n   * @param sideEffectFn Function with side-effect\n   * @returns Effect ID (can be used to unregister imperatively)\n   */\n  register<T>(\n    sourceObs: ObservableInput<T>,\n    sideEffectFn: (value: T) => void\n  ): number;\n\n  /**\n   * Subscribe to source observable using an observer object.\n   *\n   * @example\n   * effects.register(\n   *   colorMode$,\n   *   {\n   *     next: mode => localStorage.setItem('colorMode', mode),\n   *     error: err => {\n   *       console.error('Color mode error: ', err);\n   *       localStorage.removeItem('colorMode');\n   *     }\n   *   }\n   * );\n   *\n   * @param sourceObs Source observable input\n   * @param observer Observer object\n   */\n  register<T>(\n    sourceObs: ObservableInput<T>,\n    // tslint:disable-next-line: unified-signatures\n    observer: PartialObserver<T>\n  ): number;\n\n  /**\n   * Handles subscription for an observable with a side-effect.\n   *\n   * @example\n   * effects.register(\n   *   colorMode$.pipe(\n   *     tap(mode => localStorage.setItem('colorMode', mode))\n   *   )\n   * );\n   *\n   * @param sideEffectObs Observable input with side-effect\n   * @returns Effect ID (can be used to unregister imperatively)\n   */\n  register(sideEffectObs: ObservableInput<unknown>): number;\n\n  /**\n   * Handles subscription to an observable with a side-effect.\n   *\n   * @example\n   * effects.register(\n   *   colorMode$.subscribe(mode => localStorage.setItem('colorMode', mode))\n   * );\n   *\n   * @param subscription Subscription to observable with side-effect\n   */\n  // tslint:disable-next-line: unified-signatures\n  register(subscription: Subscription): void;\n\n  register<T>(\n    obsOrSub: ObservableInput<T> | Subscription,\n    fnOrObj?: ((value: T) => void) | PartialObserver<T>\n  ): number | void {\n    if (obsOrSub instanceof Subscription) {\n      this.subscription.add(obsOrSub);\n      return;\n    }\n    const effectId = RxEffects.nextId++;\n    const destroy$ = (this.destroyers[effectId] = new Subject<void>());\n    const applyBehavior = pipe(mapTo(effectId), takeUntil(destroy$));\n    if (fnOrObj != null) {\n      this.observables$.next(\n        from(obsOrSub).pipe(\n          // ternary expression is to help Typescript infer overloads\n          typeof fnOrObj === 'function' ? tap(fnOrObj) : tap(fnOrObj),\n          catchError((err) => {\n            this.errorHandler?.handleError(err);\n            return EMPTY;\n          }),\n          applyBehavior\n        )\n      );\n    } else {\n      this.observables$.next(from(obsOrSub).pipe(applyBehavior));\n    }\n    return effectId;\n  }\n\n  /**\n   * Imperatively cancel a side-effect while the component is still running.\n   *\n   * Note that all effects are automatically cancelled when a component is destroyed,\n   * so you most often won't need to call this method.\n   * @param effectId Effect ID (returned by register method)\n   */\n  unregister(effectId: number): void {\n    this.destroyers[effectId]?.next();\n  }\n\n  /**\n   * Fires a sideEffect when the instances `OnDestroy` hook is fired.\n   *\n   * @example\n   * effects.registerOnDestroy(mode => localStorage.setItem('colorMode', mode));\n   *\n   * @param sideEffect\n   */\n  registerOnDestroy(sideEffect: (value: boolean) => void): number | void {\n    return this.register(this.onDestroy$, sideEffect);\n  }\n\n  /**\n   * Operator that unsubscribes based on emission of an registered effect.\n   *\n   * @NOTICE\n   * This operator has to be placed always at the end of the operator chain (before the subscription).\n   * Otherwise we may leak as a subsequent operator could instantiate new ongoing Observables which will not get unsubscribed.\n   *\n   * @example\n   * const effectId1 = effects.register(\n   *   colorMode$.subscribe(mode => localStorage.setItem('colorMode', mode))\n   * );\n   *\n   * someValue$.pipe(\n   *    effect.untilEffect(effectId1)\n   * )\n   *\n   */\n  untilEffect(effectId: number) {\n    return <V>(source: Observable<V>) =>\n      source.pipe(\n        untilDestroyed(this),\n        takeUntil(this.effects$.pipe(filter((eId) => eId === effectId)))\n      );\n  }\n\n  /**\n   * @internal\n   */\n  ngOnDestroy(): void {\n    this._hooks$.next({ destroy: true });\n    this.subscription.unsubscribe();\n  }\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["filter","take","shareReplay","operators","pluck","takeUntil","Subject","mergeAll","share","Subscription","pipe","mapTo","from","tap","catchError","EMPTY","Injectable","Optional"],"mappings":"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"}