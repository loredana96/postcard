(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@rx-angular/state/effects', ['exports', '@angular/core', 'rxjs', 'rxjs/operators'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['rx-angular'] = global['rx-angular'] || {}, global['rx-angular'].state = global['rx-angular'].state || {}, global['rx-angular'].state.effects = {}), global.ng.core, global.rxjs, global.rxjs.operators));
}(this, (function (exports, i0, rxjs, operators) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);

    function isSingleShotHookNameGuard(name) {
        return !!name && typeof name === 'string' && name !== '';
    }
    /**
     * @internal
     * Operator to filter values for single shot observables
     */
    var singleShotOperators = function (o$) { return o$.pipe(operators.filter(function (v) { return v === true; }), operators.take(1), operators.shareReplay()); };
    /**
     * This is an operator that is used to listen to Angular lifecycle hooks.
     * It plucks a defined lefe cycle name `HookProps` and forwards values for the particular value and in the behavior of the hook e.g. single shot
     *
     * @param name
     */
    function toHook(name) {
        var operators$1 = isSingleShotHookNameGuard(name)
            ? singleShotOperators
            : function (o) { return o; };
        return function (o$) { return o$.pipe(operators.pluck(name), operators$1); };
    }
    /**
     * This operator can be used to take instances that implements `OnDestroy$` and unsubscribes from the given Observable when the instances
     * `onDestroy$` Observable emits.
     *
     * @param instanceWithLifecycle
     */
    function untilDestroyed(instanceWithLifecycle) {
        return function (source) { return source.pipe(operators.takeUntil(instanceWithLifecycle.onDestroy$)); };
    }

    /**
     * Reduces subscription boilerplate for performing observable-based side-effects in components.
     *
     * Before:
     * ```ts
     * @Component({
     *   // ...
     * })
     * export class FooComponent implements OnDestroy {
     *   private readonly destroy$ = new Subject<void>();
     *
     *   constructor() {
     *     obs$.pipe(takeUntil(this.destroy$)).subscribe(doSideEffect);
     *   }
     *
     *   ngOnDestroy(): void {
     *     this.destroy$.next();
     *     this.destroy$.complete();
     *   }
     * }
     * ```
     *
     * After:
     * ```ts
     * @Component({
     *   // ...
     *   providers: [RxEffects],
     * })
     * export class FooComponent {
     *   constructor(effects: RxEffects) {
     *     effects.register(obs$, doSideEffect);
     *     // OR
     *     effects.register(obs$.pipe(tap(doSideEffect)));
     *     // OR
     *     effects.register(obs$.subscribe(doSideEffect));
     *   }
     * }
     * ```
     *
     * NOTE: Avoid calling register/unregister/subscribe inside the side-effect function.
     */
    var RxEffects = /** @class */ (function () {
        function RxEffects(errorHandler) {
            this.errorHandler = errorHandler;
            this._hooks$ = new rxjs.Subject();
            this.observables$ = new rxjs.Subject();
            // we have to use publish here to make it hot (composition happens without subscriber)
            this.effects$ = this.observables$.pipe(operators.mergeAll(), operators.share());
            this.subscription = this.effects$.subscribe();
            this.onDestroy$ = this._hooks$.pipe(toHook('destroy'));
            this.destroyers = {};
        }
        RxEffects.prototype.register = function (obsOrSub, fnOrObj) {
            var _this = this;
            if (obsOrSub instanceof rxjs.Subscription) {
                this.subscription.add(obsOrSub);
                return;
            }
            var effectId = RxEffects.nextId++;
            var destroy$ = (this.destroyers[effectId] = new rxjs.Subject());
            var applyBehavior = rxjs.pipe(operators.mapTo(effectId), operators.takeUntil(destroy$));
            if (fnOrObj != null) {
                this.observables$.next(rxjs.from(obsOrSub).pipe(
                // ternary expression is to help Typescript infer overloads
                typeof fnOrObj === 'function' ? operators.tap(fnOrObj) : operators.tap(fnOrObj), operators.catchError(function (err) {
                    var _a;
                    (_a = _this.errorHandler) === null || _a === void 0 ? void 0 : _a.handleError(err);
                    return rxjs.EMPTY;
                }), applyBehavior));
            }
            else {
                this.observables$.next(rxjs.from(obsOrSub).pipe(applyBehavior));
            }
            return effectId;
        };
        /**
         * Imperatively cancel a side-effect while the component is still running.
         *
         * Note that all effects are automatically cancelled when a component is destroyed,
         * so you most often won't need to call this method.
         * @param effectId Effect ID (returned by register method)
         */
        RxEffects.prototype.unregister = function (effectId) {
            var _a;
            (_a = this.destroyers[effectId]) === null || _a === void 0 ? void 0 : _a.next();
        };
        /**
         * Fires a sideEffect when the instances `OnDestroy` hook is fired.
         *
         * @example
         * effects.registerOnDestroy(mode => localStorage.setItem('colorMode', mode));
         *
         * @param sideEffect
         */
        RxEffects.prototype.registerOnDestroy = function (sideEffect) {
            return this.register(this.onDestroy$, sideEffect);
        };
        /**
         * Operator that unsubscribes based on emission of an registered effect.
         *
         * @NOTICE
         * This operator has to be placed always at the end of the operator chain (before the subscription).
         * Otherwise we may leak as a subsequent operator could instantiate new ongoing Observables which will not get unsubscribed.
         *
         * @example
         * const effectId1 = effects.register(
         *   colorMode$.subscribe(mode => localStorage.setItem('colorMode', mode))
         * );
         *
         * someValue$.pipe(
         *    effect.untilEffect(effectId1)
         * )
         *
         */
        RxEffects.prototype.untilEffect = function (effectId) {
            var _this = this;
            return function (source) { return source.pipe(untilDestroyed(_this), operators.takeUntil(_this.effects$.pipe(operators.filter(function (eId) { return eId === effectId; })))); };
        };
        /**
         * @internal
         */
        RxEffects.prototype.ngOnDestroy = function () {
            this._hooks$.next({ destroy: true });
            this.subscription.unsubscribe();
        };
        return RxEffects;
    }());
    RxEffects.nextId = 0;
    /** @nocollapse */ RxEffects.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: RxEffects, deps: [{ token: i0__namespace.ErrorHandler, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ RxEffects.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: RxEffects });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: RxEffects, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () {
            return [{ type: i0__namespace.ErrorHandler, decorators: [{
                            type: i0.Optional
                        }] }];
        } });

    /**
     * Generated bundle index. Do not edit.
     */

    exports.RxEffects = RxEffects;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=state-effects.umd.js.map
