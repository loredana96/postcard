import { ErrorHandler, OnDestroy } from '@angular/core';
import { Observable, ObservableInput, PartialObserver, Subject, Subscription } from 'rxjs';
import { DestroyProp, OnDestroy$ } from './model';
import * as i0 from "@angular/core";
/**
 * Reduces subscription boilerplate for performing observable-based side-effects in components.
 *
 * Before:
 * ```ts
 * @Component({
 *   // ...
 * })
 * export class FooComponent implements OnDestroy {
 *   private readonly destroy$ = new Subject<void>();
 *
 *   constructor() {
 *     obs$.pipe(takeUntil(this.destroy$)).subscribe(doSideEffect);
 *   }
 *
 *   ngOnDestroy(): void {
 *     this.destroy$.next();
 *     this.destroy$.complete();
 *   }
 * }
 * ```
 *
 * After:
 * ```ts
 * @Component({
 *   // ...
 *   providers: [RxEffects],
 * })
 * export class FooComponent {
 *   constructor(effects: RxEffects) {
 *     effects.register(obs$, doSideEffect);
 *     // OR
 *     effects.register(obs$.pipe(tap(doSideEffect)));
 *     // OR
 *     effects.register(obs$.subscribe(doSideEffect));
 *   }
 * }
 * ```
 *
 * NOTE: Avoid calling register/unregister/subscribe inside the side-effect function.
 */
export declare class RxEffects implements OnDestroy, OnDestroy$ {
    private readonly errorHandler;
    constructor(errorHandler: ErrorHandler);
    private static nextId;
    readonly _hooks$: Subject<DestroyProp>;
    private readonly observables$;
    private readonly effects$;
    private readonly subscription;
    onDestroy$: Observable<boolean>;
    private readonly destroyers;
    /**
     * Performs a side-effect whenever a source observable emits, and handles its subscription.
     *
     * @example
     * effects.register(
     *   colorMode$,
     *   mode => localStorage.setItem('colorMode', mode)
     * );
     *
     * @param sourceObs Source observable input
     * @param sideEffectFn Function with side-effect
     * @returns Effect ID (can be used to unregister imperatively)
     */
    register<T>(sourceObs: ObservableInput<T>, sideEffectFn: (value: T) => void): number;
    /**
     * Subscribe to source observable using an observer object.
     *
     * @example
     * effects.register(
     *   colorMode$,
     *   {
     *     next: mode => localStorage.setItem('colorMode', mode),
     *     error: err => {
     *       console.error('Color mode error: ', err);
     *       localStorage.removeItem('colorMode');
     *     }
     *   }
     * );
     *
     * @param sourceObs Source observable input
     * @param observer Observer object
     */
    register<T>(sourceObs: ObservableInput<T>, observer: PartialObserver<T>): number;
    /**
     * Handles subscription for an observable with a side-effect.
     *
     * @example
     * effects.register(
     *   colorMode$.pipe(
     *     tap(mode => localStorage.setItem('colorMode', mode))
     *   )
     * );
     *
     * @param sideEffectObs Observable input with side-effect
     * @returns Effect ID (can be used to unregister imperatively)
     */
    register(sideEffectObs: ObservableInput<unknown>): number;
    /**
     * Handles subscription to an observable with a side-effect.
     *
     * @example
     * effects.register(
     *   colorMode$.subscribe(mode => localStorage.setItem('colorMode', mode))
     * );
     *
     * @param subscription Subscription to observable with side-effect
     */
    register(subscription: Subscription): void;
    /**
     * Imperatively cancel a side-effect while the component is still running.
     *
     * Note that all effects are automatically cancelled when a component is destroyed,
     * so you most often won't need to call this method.
     * @param effectId Effect ID (returned by register method)
     */
    unregister(effectId: number): void;
    /**
     * Fires a sideEffect when the instances `OnDestroy` hook is fired.
     *
     * @example
     * effects.registerOnDestroy(mode => localStorage.setItem('colorMode', mode));
     *
     * @param sideEffect
     */
    registerOnDestroy(sideEffect: (value: boolean) => void): number | void;
    /**
     * Operator that unsubscribes based on emission of an registered effect.
     *
     * @NOTICE
     * This operator has to be placed always at the end of the operator chain (before the subscription).
     * Otherwise we may leak as a subsequent operator could instantiate new ongoing Observables which will not get unsubscribed.
     *
     * @example
     * const effectId1 = effects.register(
     *   colorMode$.subscribe(mode => localStorage.setItem('colorMode', mode))
     * );
     *
     * someValue$.pipe(
     *    effect.untilEffect(effectId1)
     * )
     *
     */
    untilEffect(effectId: number): <V>(source: Observable<V>) => Observable<V>;
    /**
     * @internal
     */
    ngOnDestroy(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<RxEffects, [{ optional: true; }]>;
    static ɵprov: i0.ɵɵInjectableDeclaration<RxEffects>;
}
//# sourceMappingURL=effects.service.d.ts.map